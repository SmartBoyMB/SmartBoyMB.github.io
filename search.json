[{"title":"React Native的基础组件","date":"2022-09-02T15:49:30.492Z","url":"/SmartBoyMB.github.io/2022/09/02/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","tags":[["客户端","/SmartBoyMB.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"],["组件","/SmartBoyMB.github.io/tags/%E7%BB%84%E4%BB%B6/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["学习","/SmartBoyMB.github.io/categories/React-Native/%E5%AD%A6%E4%B9%A0/"]],"content":"函数组件与class组件 你可以在 React 中使用函数式组件或 Class 组件。最开始只有 Class 组件能够使用 state ，但自从有了 React Hooks API, 你可以为函数组件添加 state 和很多其它的功能。 Hooks 是一种面向未来的编写 React 组件的方式。 ### 函数组件 ### class组件 ## 核心组件 详细API React Native 具有许多核心组件，从表单控件到活动指示器，应有尽有。 React Native UI 组件 Android View IOS View Web analog 描述 &lt;View&gt; &lt;ViewGroup&gt; &lt;UIView&gt; &lt;div&gt; non-scrolling 一个支持带有 flexbox、样式、一些触摸处理和可访问性控件的布局的容器 &lt;Text&gt; &lt;TextView&gt; &lt;UITextView&gt; &lt;p&gt; 显示、样式和嵌套文本字符串，甚至处理触摸事件 &lt;Image&gt; &lt;ImageView&gt; &lt;UIImageView&gt; &lt;img&gt; 显示不同类型的图像 |&lt;ScrollView&gt;|&lt;ScrollView&gt;|&lt;UIScrollView&gt;|&lt;div&gt;|可以包含多个组件和视图的通用滚动容器| |&lt;TextInput&gt;|&lt;EditText&gt;|&lt;UITextField&gt;|&lt;input type=&quot;text&quot;&gt;|允许用户输入文本| 常用场景 处理文本输入 TextInput是一个允许用户输入文本的基础组件。它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时被调用。另外还有一个名为onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用。 滚动视图 ScrollView组件 ScrollViews可以通过使用pagingEnabled属性来允许使用滑动手势对视图进行分页，在 Android 上也可以利用ViewPager组件水平滑动视图。 在 iOS 上包含单个子元素的 ScrollViews 可以允许用户对内容进行缩放. 通过设置maximumZoomScale和minimumZoomScale两者的属性, 您的用户能够利用捏合以及扩大手势来放大或缩小。 ScrollView适合用来显示数量不多的滚动元素。放置在ScrollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外。如果你需要显示较长的滚动列表，那么应该使用功能差不多但性能更好的FlatList组件。 ### 使用长列表 FlatList * FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。 FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。 FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。 SectionList组件 渲染一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。 区分平台方法 Platform模块 React Native 提供了一个检测当前运行平台的模块。如果组件只有一小部分代码需要依据平台定制，那么这个模块就可以派上用场。 方法和属性： * Platform.OS: Platform.OS在 iOS 上会返回ios，而在 Android 设备或模拟器上则会返回android。 * Platform.select(): * 还有个实用的方法是 Platform.select()，它可以以 Platform.OS 为 key，从传入的对象中返回对应平台的值，见下面的示例代码会根据平台的不同返回不同的 container 样式 —— iOS 上背景色为红色，而 android 为蓝色。 * 这一方法可以接受任何合法类型的参数，因此你也可以直接用它针对不同平台返回不同的组件: * Platform.Version: * 在 Android 上，Version属性是一个数字，表示 Android 的 api level。 在 iOS 上，Version属性是-[UIDevice systemVersion]的返回值，具体形式为一个表示当前系统版本的字符串。比如可能是&quot;10.3&quot;。 特定平台扩展名 当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native 会检测某个文件是否具有.ios.或是.android.的扩展名，然后根据当前运行的平台自动加载正确对应的文件。 文件名： BigButton.ios.js BigButton.android.js 引用：import BigButton from './BigButton'; 如果你还希望在 web 端复用 React Native 的代码，那么还可以使用.native.js的扩展名。此时 iOS 和 Android 会使用BigButton.native.js文件，而 web 端会使用BigButton.js。（注意目前官方并没有直接提供 web 端的支持，请在社区搜索第三方方案）。 比如在你的项目中存在如下的两个文件: Container.js # 由 Webpack, Rollup 或者其他打包工具打包的文件 Container.native.js # 由 React Native 自带打包工具(Metro) 为ios和android 打包的文件 在引用时并不需要添加.native.后缀: import Container from './Container'; 提示: 为避免在构建后的 Web 生产环境的代码中出现多余代码，要记得在你的 Web 打包工具中配置忽略.native.js结尾的文件, 这样可以减少打包后文件的大小"},{"title":"React Native的性能优化","date":"2022-09-02T15:49:30.422Z","url":"/SmartBoyMB.github.io/2022/09/02/%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/","tags":[["客户端","/SmartBoyMB.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"],["优化","/SmartBoyMB.github.io/tags/%E4%BC%98%E5%8C%96/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["学习","/SmartBoyMB.github.io/categories/React-Native/%E5%AD%A6%E4%B9%A0/"]],"content":"官方文档"},{"title":"React Native的页面导航","date":"2022-09-02T15:49:30.367Z","url":"/SmartBoyMB.github.io/2022/09/02/%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/","tags":[["客户端","/SmartBoyMB.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"],["导航器","/SmartBoyMB.github.io/tags/%E5%AF%BC%E8%88%AA%E5%99%A8/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["Navigater","/SmartBoyMB.github.io/categories/React-Native/Navigater/"],["学习","/SmartBoyMB.github.io/categories/React-Native/Navigater/%E5%AD%A6%E4%B9%A0/"]],"content":"Navigation官方教程 不同版本之间的使用差距比较大，具体版本具体分析。"},{"title":"React Native的网络通信","date":"2022-09-02T15:49:30.307Z","url":"/SmartBoyMB.github.io/2022/09/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/","tags":[["客户端","/SmartBoyMB.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"],["网络","/SmartBoyMB.github.io/tags/%E7%BD%91%E7%BB%9C/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["学习","/SmartBoyMB.github.io/categories/React-Native/%E5%AD%A6%E4%B9%A0/"]],"content":"使用Fetch React Native 提供了和 web 标准一致的Fetch API，用于满足开发者访问网络的需求。 发起请求： 要从任意地址获取内容的话，只需简单地将网址作为参数传递给 fetch 方法即可（fetch 这个词本身也就是获取的意思）： ## 处理响应： * 网络请求天然是一种异步操作（在等待期间运行其他程序），Fetch 方法会返回一个Promise，这种模式可以简化异步风格的代码；或者使用 ES2017 标准中的async/await 语法。 别忘了 catch 住fetch可能抛出的异常，否则出错时你可能看不到任何提示。 ## 注意 &gt;默认情况下，iOS 会阻止所有 http 的请求，以督促开发者使用 https。如果你仍然需要使用 http 协议，那么首先需要添加一个 App Transport Security 的例外，详细可参考这篇帖子。 从 Android9 开始，也会默认阻止 http 请求，请参考相关配置 其他网络库 React Native 中已经内置了XMLHttpRequest API(也就是俗称的 ajax)。一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如frisbee或是axios等。但注意不能使用 jQuery，因为 jQuery 中还使用了很多浏览器中才有而 RN 中没有的东西（所以也不是所有 web 中的 ajax 库都可以直接使用）。 基于WebSocket React Native还有WebSocket，这种协议可以支持在双TCP 连接上提供全工的通信信道。 相关链接 "},{"title":"React Native的手势交互","date":"2022-09-02T15:49:30.177Z","url":"/SmartBoyMB.github.io/2022/09/02/%E6%89%8B%E5%8A%BF%E4%BA%A4%E4%BA%92/","tags":[["客户端","/SmartBoyMB.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"],["交互","/SmartBoyMB.github.io/tags/%E4%BA%A4%E4%BA%92/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["学习","/SmartBoyMB.github.io/categories/React-Native/%E5%AD%A6%E4%B9%A0/"]],"content":"处理触摸事件 Button 简单的按钮，常用的属性方法是Color（调整颜色）和 onPress()（添加点击事件）。 ### Touchable系列组件 Button组件的样式是固定的，所以如果它的外观并不怎么搭配你的设计，那就需要使用Touchable系列组件定制自己需要的样式。 TouchableHighlight：制作按钮或者链接，注意此组件的背景会在用户手指按下时变暗。 TouchableNativeFeedback：（android）用户手指按下时形成类似墨水涟漪的视觉效果。 TouchableOpacity：在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。 TouchableWithoutFeedback：处理点击事件的同时不显示任何视觉反馈。 需要检测用户是否进行了长按操作。可以在上面列出的任意组件中使用onLongPress属性来实现。 动画 React Native 提供了两个互补的动画系统：用于创建精细的交互控制的动画Animated和用于全局的布局动画LayoutAnimation。 Animated 使得开发者可以简洁地实现各种各样的动画和交互方式，并且具备极高的性能。 Animated旨在以声明的形式来定义动画的输入与输出，在其中建立一个可配置的变化函数，然后使用start/stop方法来控制动画按顺序执行。 Animated仅封装了 6 个可以动画化的组件：View、Text、Image、ScrollView、FlatList和SectionList，不过你也可以使用Animated.createAnimatedComponent()来封装你自己的组件。 配置动画 Animated提供了三种动画类型。每种动画类型都提供了特定的函数曲线，用于控制动画值从初始值变化到最终值的变化过程： Animated.decay()以指定的初始速度开始变化，然后变化速度越来越慢直至停下。 Animated.spring()提供了一个基础的弹簧物理模型. Animated.timing()使用easing 函数让数值随时间动起来。 大多数情况下你应该使用timing()。默认情况下，它使用对称的 easeInOut 曲线，将对象逐渐加速到全速，然后通过逐渐减速停止结束。 组合动画 多个动画可以通过parallel（同时执行）、sequence（顺序执行）、stagger和delay来组合使用。它们中的每一个都接受一个要执行的动画数组，并且自动在适当的时候调用start/stop。 默认情况下，如果任何一个动画被停止或中断了，组内所有其它的动画也会被停止。Parallel 有一个stopTogether属性，如果设置为false，可以禁用自动停止。 在Animated文档的组合动画一节中列出了所有的组合方法。 合成动画值 你可以使用加减乘除以及取余等运算来把两个动画值合成为一个新的动画值： Animated.add() Animated.subtract() Animated.divide() Animated.modulo() Animated.multiply() 插值 所有动画值都可以执行插值（interpolation）操作。插值是指将一定范围的输入值映射到另一组不同的输出值，一般我们使用线性的映射，但是也可以使用 easing 函数。默认情况下，它会将曲线外推到给定范围之外，但您也可以让它限制为输出值. ## 追踪动态值 动画中所设的值还可以通过跟踪别的值得到。你只要把 toValue 设置成另一个动态值而不是一个普通数字就行了。比如我们可以用弹跳动画来实现聊天头像的闪动，又比如通过timing设置duration:0来实现快速的跟随。他们还可以使用插值来进行组合。 变量 leader 和 follower 通过 Animated.ValueXY() 来定义。这是一个方便的处理 2D 交互的办法，譬如旋转或拖拽。它是一个简单的包含了两个Animated.Value实例的包装，然后提供了一系列辅助函数，使得ValueXY在许多时候可以替代Value来使用。比如在上面的代码片段中，leader和follower可以同时为valueXY类型，这样 x 和 y 的值都会被跟踪. 跟踪手势 Animated.event是 Animated 中与输入有关的部分，允许手势或其它事件直接绑定到动态值上。它通过一个结构化的映射语法来完成，使得复杂事件对象中的值可以被正确的解开。第一层是一个数组，允许同时映射多个值，然后数组的每一个元素是一个嵌套的对象。在下面的例子里，你可以发现scrollX被映射到了event.nativeEvent.contentOffset.x(event通常是回调函数的第一个参数)，并且pan.x和pan.y分别映射到gestureState.dx和gestureState.dy（gestureState是传递给PanResponder回调函数的第二个参数）。 例如，在使用水平的滚动手势时，可以像下面这样将 event.nativeEvent.contentOffset.x 映射到 scrollX (一个 Animated.Value)。 手势响应系统 复杂的手势响应 "},{"title":"React Native 存在的问题","date":"2022-09-02T15:49:30.058Z","url":"/SmartBoyMB.github.io/2022/09/02/RN_problems/","tags":[["problems","/SmartBoyMB.github.io/tags/problems/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["学习","/SmartBoyMB.github.io/categories/React-Native/%E5%AD%A6%E4%B9%A0/"]],"content":"官方配置链接 官网RN环境配置 JDK版本不兼容问题 报错信息： Android Studio Error &quot;Unsupported class file major version 62&quot; 原因： jdk版本过高，编译的类文件不匹配，&quot;version 62&quot;是指 jdk 18。 解决方法： 使用低版本的jdk，Android 工具链仅支持为 Java 11 编译的类（如果项目配置正确）。 如果遇到官网下载慢的问题，可以使用镜像网站下载。 相关链接： stack_overflow：jdk问题 VSCode调试时的问题 报错信息： 执行命令 _modules.bin-native.cmd run-android --no-packager 时出错 (error code 101) 原因： vs code启动模拟器的报错 解决办法： 首先在终端通过 adb devices 检查模拟器或者真机是否正常链接。 然后重新刷新React Native工具包（在编译器底部栏）或者重启vscode。 最好先在命令行中通过cyarn android # 或者 yarn react-native run-android，启动工程后再尝试用VScode调试。 检查Metro服务（类似于webpack）是否正常启动，如果没有可以通过 yarn start 命令单独启动。 初始化构建TS模板React Native项目问题 报错信息： error An unexpected error occurred: &quot;: Not found&quot;. 原因： react-native-cli是旧版本 解决方法： 方法1: 删除旧的 react-native-cli:npm uninstall -g react-native-cli 从“react-native-community”安装新的: npm i -g @react-native-community/cli 之后，使用以下命令初始化项目: npx react-native init MyApp --template react-native-template-typescript 方法2：（方法1成功解决，方法2并未尝试） 运行以下命令开始升级到最新版本的过程: npx react-native upgrade 你可以通过传递一个参数来指定一个 React Native 版本，例如升级到0.61.0-rc.0运行: npx react-native upgrade 0.61.0-rc.0 相关链接：   Andorid App 安装缺少密钥库问题 报错信息 原因 问题是构建正在寻找调试密钥库并且找不到它，在android/app 文件夹下缺少密钥调试库。 应该是app构建apk时的需要的密钥库缺失。 解决方案 第一种： cd android/app 后运行命令 keytool -genkey -v -keystore debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000 （我使用的，已解决） 第二种： 只需从官方模板下载 复制debug.keystore到您的android/app/. RN fetch()网络请求失败问题 错误信息 RN开发中，我在本机上部署了node服务器端，客户端使用fetch()时返回错误&quot;network request failed&quot;。部署在android模拟器，URL为&quot;;。 原因 URL中的localhost的解析有问题。 ps： 这里属于是自己脑子有点问题，琢磨了两天，也测试后端接受请求是否有问题，写demo测试能够请求到服务器，忘记了项目在模拟器上，&quot;localhost&quot; 解析会有问题。 在查找解决方案的时候发现iOS上这样的情况也有，但问题可能是iOS不允许http请求，具体的解决方法可以参考 解决方法 终端 ifconfig 查询自己的服务器ip 将localhost更换为ip。 React-Nagivation 版本问题 错误信息 App加载白屏。 调试器报以下错误 原因 导航器的版本用了4.x.x，引起了一些错误。 解决办法 安装导航器（这是我们使用3.x版本） yarn add react-navigation@3.12.0 ps: 没安装handler会报500 安装navigation-handler yarn add react-native-gesture-handler react-native-reanimated"},{"title":"FlexBox 布局","date":"2022-09-02T15:49:30.001Z","url":"/SmartBoyMB.github.io/2022/09/02/FlexBox%E5%B8%83%E5%B1%80/","tags":[["布局","/SmartBoyMB.github.io/tags/%E5%B8%83%E5%B1%80/"],["flexbox","/SmartBoyMB.github.io/tags/flexbox/"]],"categories":[["React Native","/SmartBoyMB.github.io/categories/React-Native/"],["学习","/SmartBoyMB.github.io/categories/React-Native/%E5%AD%A6%E4%B9%A0/"]],"content":"简介 我们在 React Native 中使用 flexbox 规则来指定某个组件的子元素的布局。Flexbox 可以在不同屏幕尺寸上提供一致的布局结构。 一般来说，使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。 相关链接 全部的属性链接。 比较全面的总结。 关于position。 即使展示的总结 容器 容器的margin（到外容器的距离）和padding（到内容器的距离） React Native 与 CSS 的对比 React Native 中的 Flexbox 的工作原理和 web 上的 CSS 基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值为column（而不是row），alignContent默认值为 flex-start（而不是 stretch）, flexShrink 默认值为0 （而不是1）, 而flex只能指定一个数字值。 常用属性 Flex Flex 属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex 属性值被分割成多个部分属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex 属性值按比例被分割成多个部分。 在设置了flex: 1的容器 view 中，有红色，黄色和绿色三个子 view。红色 view 设置了flex: 1，黄色 view 设置了flex: 2，绿色 view 设置了flex: 3。1+2+3 = 6，这意味着红色 view 占据整个区域的1/6，黄色 view 占据整个区域的2/6，绿色 view 占据整个区域的3/6。 Flex Direction 在组件的style中指定flexDirection可以决定布局的主轴。决定子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列.默认值是竖直轴(column)方向。 ROW（默认） 从左到右对齐孩子。如果启用了换行，则下一行将从容器左侧的第一项下方开始。 COLUMN 从上到下对齐子项。如果启用了换行，则下一行将从容器顶部的左侧第一项开始。 ROW REVERSE 将孩子从右到左对齐。如果启用了换行，则下一行将从容器右侧的第一项下方开始。 COLUMN REVERSE 将子项从下到上对齐。如果启用了换行，则下一行将从容器底部的左侧第一项开始。 Layout Direction 布局方向指定层次结构中的子项和文本的布局方向。 布局方向也会影响边缘开始和结束所指的内容。 默认情况下，React Native 使用 LTR 布局方向进行布局。 在这种模式下，start 指的是左，end 指的是右。 LTR（默认值） 文本和子项从左到右排列。 应用于元素开头的边距和填充应用于左侧。 RTL 文本和子元素从右到左排列。 应用于元素开头的边距和填充应用于右侧。 Justify Content 在组件的 style 中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有： flex-start(默认值) 将容器的子项与容器主轴的起点对齐。 flex-end 将容器的子元素与容器主轴的末端对齐。 center 在容器主轴的中心对齐容器的子项。 space-between 在容器的主轴上均匀地隔开子级，在子级之间分配剩余空间。 space-around 在容器的主轴上均匀地隔开子项，将剩余的空间分布在子项周围。 与 space-between 相比，使用 space-around 将导致空间被分配到第一个孩子的开头和最后一个孩子的结尾。 space-evenly 在对齐容器内沿主轴均匀分布子项。 每对相邻项之间的间距，主开始边和第一项，主结束边和最后一项，都完全相同。 Align Items 在组件的 style 中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。决定子元素是应该靠近次轴的起始端还是末尾段分布亦或应该均匀分布。可用的选项有: strength（默认值） 拉伸容器的子项以匹配容器横轴的高度。 flex-start 将容器的子项与容器的交叉轴的起点对齐。 flex-end 将容器的子项与容器的横轴末端对齐。 center 在容器横轴的中心对齐容器的子项。 baseline 沿公共基线对齐容器的子项。 可以将单个孩子设置为其父母的参考基线。 注意：要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。以下面的代码为例：只有将子元素样式中的width: 50去掉之后，alignItems: 'stretch'才能生效。 Align Self alignSelf 具有与 alignItems 相同的选项和效果，但您可以将此属性应用于单个子项以更改其在其父项中的对齐方式，而不是影响容器中的子项。 alignSelf 使用时覆盖父级alignItems 设置的任何选项。"},{"title":"React基础知识","date":"2022-09-02T15:48:09.566Z","url":"/SmartBoyMB.github.io/2022/09/02/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","tags":[["基础知识","/SmartBoyMB.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"categories":[["React","/SmartBoyMB.github.io/categories/React/"],["学习","/SmartBoyMB.github.io/categories/React/%E5%AD%A6%E4%B9%A0/"]],"content":"总览 React的元素渲染 元素 元素是构成 React 应用的最小单位，它用于描述屏幕上输出的内容。 const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 渲染 在此 div 中的所有内容都将由 React DOM 来管理，所以我们将其称为 &quot;根&quot; DOM 节点。 我们用 React 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React 的话，你可能会需要在不同的部分单独定义 React 根节点。 要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上。 组件开发 class组件 函数组件 函数组件 我们封装一个输出 &quot;Hello World！&quot; 的组件，组件名为 HelloMessage： const element = &lt;HelloMessage /&gt;为用户自定义的组件。 注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 如果我们需要向组件传递参数，可以使用 props,实例如下: 复合组件实例 类组件 除了函数组件外我们还可以创建一个 React.Component 的 ES6 类，该类封装了要展示的元素，需要注意的是在 render() 方法中，需要使用 this.props 替换 props。 JSX语法 React 使用 JSX 来替代常规的 JavaScript。(常用箭头函数) JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 我们不需要一定使用 JSX，但它有以下优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。 它是类型安全的，在编译过程中就能发现错误。 使用 JSX 编写模板更加简单快速。 代码示例： const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; React State(状态) React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。 React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。 以下实例创建一个名称扩展为 React.Component 的 ES6 类，在 render() 方法中使用 this.state 来修改当前的时间。 添加一个类构造函数来初始化状态 this.state，类组件应始终使用 props 调用基础构造函数。 React Props state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。 默认props 可以通过组建类的 defalutProps属性设置默认值。 生命周期 组件的生命周期可分成三个状态： Mounting(挂载)：已插入真实 DOM Updating(更新)：正在被重新渲染 Unmounting(卸载)：已移出真实 DOM 生命周期方法 在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。 每当 Clock 组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。 同样，每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。 componentDidMount() 与 componentWillUnmount() 方法被称作生命周期钩子。 挂载 当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下： constructor()]: 在 React 组件挂载之前，会调用它的构造函数。 getDerivedStateFromProps(): 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。 render(): render() 方法是 class 组件中唯一必须实现的方法。 componentDidMount(): 在组件挂载后（插入 DOM 树中）立即调用。 更新 每当组件的 state 或 props 发生变化时，组件就会更新。 当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下： getDerivedStateFromProps(): 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。 shouldComponentUpdate():当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。 render(): render() 方法是 class 组件中唯一必须实现的方法。 getSnapshotBeforeUpdate(): 在最近一次渲染输出（提交到 DOM 节点）之前调用。 componentDidUpdate(): 在更新后会被立即调用。 卸载 当组件从 DOM 中移除时会调用如下方法： componentWillUnmount(): 在组件卸载及销毁之前直接调用。 render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。这些方法的详细说明，可以参考官方文档。 一个组件加载的过程： 数据自顶向下流动 父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。 这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。 这通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。 如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。 为了表明所有组件都是真正隔离的，我们可以创建一个 App 组件，它渲染三个Clock： React组件API setState(设置状态): setState(object nextState[, function callback]) nextState，将要设置的新状态，该状态会和当前的state合并 callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。 不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。 setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。 setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。 replaceState(替换状态): replaceState(object nextState[, function callback]) nextState，将要设置的新状态，该状态会替换当前的state。 callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。 replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。 setProps(设置属性): setProps(object nextProps[, function callback]) 设置组件属性，并重新渲染组件。 props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。 更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。 replaceProps(替换属性): replaceProps(object nextProps[, function callback]) nextProps，将要设置的新属性，该属性会替换当前的props。 callback，可选参数，回调函数。该函数会在replaceProps设置成功，且组件重新渲染后调用。 replaceProps()方法与setProps类似，但它会删除原有props。 forceUpdate(强制更新): forceUpdate([function callback]) callback，可选参数，回调函数。该函数会在组件render()方法调用后调用。 forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。 forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render() 一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。 findDOMNode(获取DOM节点): DOMElement findDOMNode() 返回值：true或false，表示组件是否已挂载到DOM中 isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。 isMounted 的方法在 ES6 中已经废除。主要的原因是它经过实际使用与测试可能不足以检测组件是否挂载，尤其是对于有一些异步的程序情况，以及逻辑上造成混乱。现在用以下方法代替：componentDidMount() { this.mounted = true; } componentWillUnmount() { this.mounted = false; } SetState()须知: 不要直接更新状态 例如，此代码不会重新渲染组件： // Wrong this.state.comment = 'Hello'; 应当使用 setState(): // Correct this.setState(&#123;comment: 'Hello'&#125;); 构造函数是唯一能够初始化 this.state 的地方。 状态更新可能是异步的 React 可以将多个 setState() 调用合并成一个调用来提高性能。 因为 this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。 例如，此代码可能无法更新计数器： // Wrong this.setState(&#123; counter: this.state.counter + this.props.increment, &#125;); 要修复它，请使用第二种形式的 setState() 来接受一个函数而不是一个对象。 该函数将接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数： // Correct this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment &#125;)); 上方代码使用了箭头函数，但它也适用于常规函数： // Correct this.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;; &#125;); 状态更新合并 当你调用 setState() 时，React 将你提供的对象合并到当前状态。 例如，你的状态可能包含一些独立的变量： constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125; 你可以调用 setState() 独立地更新它们： componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125; 这里的合并是浅合并，也就是说 this.setState({comments}) 完整保留了 this.state.posts，但完全替换了 this.state.comments。"},{"title":"react Hooks","date":"2022-09-02T15:48:09.515Z","url":"/SmartBoyMB.github.io/2022/09/02/Hooks/","tags":[["Hooks","/SmartBoyMB.github.io/tags/Hooks/"]],"categories":[["React","/SmartBoyMB.github.io/categories/React/"],["学习","/SmartBoyMB.github.io/categories/React/%E5%AD%A6%E4%B9%A0/"]],"content":"介绍 Hooks 是让你从函数组件中“钩入”React 状态和生命周期特性的函数。Hooks 在类中不起作用——它们让你在没有类的情况下使用 React。 理解：函数组件没有办法存储react的状态和状态转移的操作，于是加入了钩子（Hook）来提供React的状态和对React操作的接口。 使用规则 Hooks 是 JavaScript 函数，但它们强加了两个额外的规则： 只在顶层调用 Hooks 。不要在循环、条件或嵌套函数中调用 Hook。 仅从 React 函数组件调用 Hooks 。不要从常规 JavaScript 函数调用 Hooks。（还有一个有效的地方可以调用 Hooks——你自己的自定义 Hooks。我们稍后会了解它们。） 可以建立自定义的Hook，但是记住用use开头，否则检查规则会不通过。 详细规则：Hooks 规则 Basic Hooks useState: const [state,setState] = useState(initialState); 返回一个有状态的值，以及一个更新它的函数。 在初始渲染期间，返回的状态 ( state) 与作为第一个参数 ( initialState) 传递的值相同。 该setState函数用于更新状态。它接受一个新的状态值并将组件的重新渲染排入队列。 useEffect: useEffect(didUpdate); 接受包含命令式的、可能有效的代码的函数。 函数组件的主体（称为 React 的渲染阶段）中不允许突变、订阅、计时器、日志记录和其他副作用。 这样做会导致 UI 中出现令人困惑的错误和不一致。 传递给 useEffect 的函数将在渲染提交到屏幕后运行。 默认情况下，效果会在每次完成渲染后运行，但您可以选择仅在某些值发生更改时触发它们。渲染前触发使用useLayoutEffect。 传递给的函数useEffect可以返回一个清理函数，在组件从DOM中卸载时调用。 useContext: const value = useContext(MyContext); 接受一个上下文对象（从 React.createContext 返回的值）并返回该上下文的当前上下文值。 当前上下文值由树中调用组件上方最近的 &lt;MyContext.Provider&gt; 的 value prop 确定。 当组件上方最近的 &lt;MyContext.Provider&gt; 更新时，此 Hook 将触发重新渲染，并将最新的上下文值传递给该 MyContext 提供程序。 即使祖先使用 React.memo 或 shouldComponentUpdate，仍然会使用 useContext 从组件本身开始重新渲染。 参数 MyContext必须是上下文对象本身： 正确的： useContext(MyContext) 不正确： useContext(MyContext.Consumer) 不正确： useContext(MyContext.Provider) Additional Hooks useReducer: const [state, dispatch] = useReducer(reducer, initialArg, init); useState的替代方法，接受一个（state，action）=&gt; newState 类型的reducer，并返回与调度方法配对的当前状态。 当具有涉及多个子值的复杂状态逻辑或下一个状态取决于前一个状态时，useReducer比useState更优秀。useReducer还可以优化触发深度更新的组件的性能，因为可以传递dispatch而不是回调。 设定指定状态： 最简单的方法是将初始状态作为第二个参数传递。 也可以迟钝地创建初始状态：传递一个init函数作为第三个参数。初始状态将设置为init(initialArg)。 useCallback: 返回一个记忆化的回调。 传递一个内联回调和一组依赖项。useCallback将返回回调的记忆版本，仅当依赖项之一发生更改时才会更改。这在将回调传递给依赖引用相等以防止不必要的渲染的优化子组件时（例如shouldComponentUpdate）很有用。 useCallback(fn, deps)相当于useMemo(() =&gt; fn, deps)。 useMemo: const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 返回一个记忆值。 传递一个“create”函数和一个依赖数组。useMemo仅当依赖项之一发生更改时才会重新计算记忆值。这种优化有助于避免在每次渲染时进行昂贵的计算。请记住，传递给的函数useMemo在渲染期间运行。不要在那里做任何你在渲染时通常不会做的事情。例如，副作用属于useEffect，而不是useMemo。 如果没有提供数组，则每次渲染都会计算一个新值。您可以依赖useMemo作为性能优化，而不是作为语义保证。将来，React 可能会选择“忘记”一些先前记忆的值并在下一次渲染时重新计算它们，例如为屏幕外组件释放内存。编写你的代码，让它在没有的情况下仍然可以工作useMemo——然后添加它以优化性能。 useRef: const refContainer = useRef(initialValue); useRef返回一个可变 ref 对象，其.current属性初始化为传递的参数 ( initialValue)。返回的对象将在组件的整个生命周期内持续存在。 有些情况下，我们需要保证函数组件每次 render 之后，某些变量不会被重复申明，比如说 Dom 节点，定时器的 id 等等。 在类组件中，我们完全可以通过给类添加一个自定义属性来保留，比如说 this.xxx， 但是函数组件没有 this，我们就需要使用 useRef 来实现。 与useState的对比： useState的值更新触发重新渲染，useRef的值更新不触发渲染。 useState的是异步更新react的，useRef是同步更新的。 useImpeativeHandle: useImperativeHandle(ref, createHandle, [deps]) 子组件利用useImperativeHandle可以呈现方法或者属性给让父组件调用，可以控制显示的视野有多少。 ref:需要被赋值的ref对象。 createHandle: createHandle函数的返回值作为ref.current的值。 [deps]: 依赖数组，依赖发生变化会重新执行createHandle函数。 建议useImperativeHandle和forwardRef同时使用，减少暴露给父组件的属性，避免使用ref这样的命令式代码。 useLayoutEffect: 模板与 useEffect 相同，但它在所有 DOM 突变后同步触发。 使用它从 DOM 中读取布局并同步重新渲染。 在 useLayoutEffect 中安排的更新将在浏览器有机会绘制之前同步刷新。 尽可能首选标准 useEffect 以避免阻塞视觉更新。 useDebugValue: useDebugValue(value) useDebugValue可用于在 React DevTools 中显示自定义钩子的标签。 例如，考虑在“构建您自己的 Hooks”中描述的 useFriendStatus 自定义 Hook。 useTransition: const [isPending, startTransition] = useTransition(); 返回转换的挂起状态的有状态值，以及启动它的函数。 startTransition 将提供的回调中的更新标记为转换。 isPending 指示转换何时处于活动状态。 useId: const id = useId(); useId是一个钩子，用于生成在服务器和客户端之间稳定的唯一 ID，同时避免水合不匹配。 useId不适用于在列表中生成键。密钥应该从您的数据中生成。 Library Hooks(为库作者提供的) 名称 作用 useSyncExternalStore  useInsertionEffect  "},{"title":"npm 下载react项目时发生的错误","date":"2022-09-02T15:44:45.917Z","url":"/SmartBoyMB.github.io/2022/09/02/npm%E4%B8%8B%E8%BD%BDreact%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%8F%91%E7%94%9F%E7%9A%84%E9%94%99%E8%AF%AF/","tags":[["problems","/SmartBoyMB.github.io/tags/problems/"]],"categories":[["React","/SmartBoyMB.github.io/categories/React/"],["学习","/SmartBoyMB.github.io/categories/React/%E5%AD%A6%E4%B9%A0/"]],"content":"问题名 eresolve unable to resolve dependency tree react ## 原因 npm install 因版本问题导致的报错， 依赖项中存在无法解决的冲突，npm@7 现在尝试安装它们，而npm@6没有 ## 解决方案： 使用了 npm config set legacy-peer-deps true 命令解决了问题 原理：npm 从版本v7开始，install就默认以 peerDependencies的方式去下载了。命令用于绕过peerDependency里依赖的自动安装，它告诉npm忽略项目中引入的各个依赖模块之间依赖相同但版本不同的问题，以npm v3-v6的方式去继续执行安装操作"},{"title":"培训课程学习","date":"2022-09-02T15:43:04.151Z","url":"/SmartBoyMB.github.io/2022/09/02/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","tags":[["实习","/SmartBoyMB.github.io/tags/%E5%AE%9E%E4%B9%A0/"],["心得","/SmartBoyMB.github.io/tags/%E5%BF%83%E5%BE%97/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"以业务为中心 技术应该为业务服务，业务的形态决定了技术的形态。学习技术应该向业务靠拢，既能有学习动力，也方便于现实中能有快速产出。 积极了解业务，以业务为导向，不要闭门造车。在设计时，一定要去积极了解业务，才能对需求有比较准确的定位，不能自己一拍脑袋决定，而是要积极沟通，详细了解用户痛点，才能更好的把握需求。 识别核心的需求，避免过度设计，舍大取小。对于需求的优先级要有概念，对于优先级高的能解决核心问题的需求才是最需要关注的点，而不是花大量的时间在目前不太需要的需求，或者付出与受益比例小的需求上。 在工作中的态度 主人翁思想：对事情应该自我驱动，为自己的工作负责，主动去思考，而不是被动去接受业务。提高自己的主观能动性是提升自己能力的好方法。 追求卓越：对于问题的根本原因要有探究精神，了解逻辑底层和问题本质会在未来的工作中起到很关键的作用，表面上多花费了时间，但是积累下来，未来会减少很多弯路和不必要的时间浪费，能提升自己的效率。 持续学习：学无止境，一是学习时间无止境，而是学习范围无止境，在深度拓宽的同时也要拓宽自己的知识广度，要做到大体上了解，有方向上精通。 心态开放：敢于发言也敢于提出建议，也敢于接受不足接受建议。同时也要能为对方思考，理解对方的想法和不同。 学习到的方法论 5Why：挖掘问题的深度，五层以上大概率就是根本原因，要积极学习积极挖掘，但也要避免浪费精力，控制时间，亦如学习，学到新知识中又有新知识，也需要保证不会浪费太多时间去追求广度。 效率至上四步走：自动化一切，复杂问题简单化，简单问题标准化，标准问题流程化，流程问题自动化。实际上自动化问题的过程也就是总结自己方法，以及拆分问题细化处理的过程，应当总结出自己应对问题的方法论，这样效率有很大的提升。 KISS原则：快速迭代的思想，保证目的是一目了然的，也就是说要逐步迭代演技，小步快跑的思想，每次迭代应该目的单一且不复杂，保证新的一轮迭代的目的是明确的严谨的，会更好的规范迭代的过程。 保证质量的核心思想 风险前置：对于风险应该从始至终提前考虑，也是贯彻于软件开发整个生命周期，这样修复的代价就会越小，避免后期人力的浪费。 测试：保证质量应该重心在设计，不能依赖于最后的测试，测试也是抽样的，并不是万全之策，要记住测试只是最后的兜底保障。 历史代码：自己要在前人的代码上进行开发，也要交付给别人进行维护，自己的代码规范很重要，但也要学会如何高效的在质量低的代码上进行开发。 协作：大的需求的项目开发，往往任务划分和交互会很复杂，协作很重要，也很有挑战。 代码编写 代码原则： 避免直接、简单直接、和团队内要保持一致 命名： 命名带有含义并且表达准确，长度适中，不要有字面量直接作为参数。 函数结构： 参数三个以下，超过要封装成对象；一个函数内的内容抽象层级要在一个层级；功能应该专一，不要有其他的副作用；用异常代替返回码 注释： 代码就是最好的注释；注释意图（why），而不是注释实现；好代码永远大于坏代码+好注释； 日志： 保持打日志的习惯；注意日志的分级：ERROR，WARN，INFO（一般用在关键业务核心路径处理结果），DEBUG，TRACE； 异常： 早throw，晚catch的原则，异常的处理层往往在抛出层之上。不能忽略异常，并记得关闭资源。异常处理的性能成本非常高，要慎重。 整体开发流程 需求-&gt;设计-&gt;开发-&gt;测试-&gt;集成-&gt;集成测试-&gt;灰度-&gt;全量&amp;线上运维 项目管理的重点 项目等级： * 等级：S/A/B/迭代 根据项目重要性和复杂性分级，不等于优先级 要事第一原则 接受项目初期： * 查看立项报告（根据模版：了解为什么要做，做什么，目标是什么，怎么做，评估方式，需要的资源等问题。 了解项目机制：包括整体管理策略、项目相关方、沟通管理机制、问题处理机制、风险管理机制、知识管理机制等。 如何保障交付： * 工作拆分WBS：复杂工作简单化，分层拆分，不重不漏，颗粒度要小，每一条任务都要时间规定和负责人。 责任分配RACI：任务都要有负责人（R）、当责者（A）、咨询方（C）、告知者（I）。 进度计划：做好甘特图管理项目各项任务的进度。 质量管理：准备好的定义标准（DoR），完成的定义标准（DoD） 参与复盘：开放心态，持续反思，不断进步。 资料： 《clean code》 "},{"title":"RN知识问答","date":"2022-09-02T15:43:04.113Z","url":"/SmartBoyMB.github.io/2022/09/02/RN%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/","tags":[["实习","/SmartBoyMB.github.io/tags/%E5%AE%9E%E4%B9%A0/"],["Q&A","/SmartBoyMB.github.io/tags/Q-A/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"Q&amp;A Q1:：对于react-redux的理解，是否在项目中使用 reward：基本熟悉逻辑，但是对于api还是不了解 Q2：flatList主要属性，使用到的属性 reward：一些属性的作用记的不牢，比如keyExtra， 分配key其实是为了提高更新时效率 Q3：react组件的生命周期，当props和state更新时的生命周期 rewart：主要的生命周期和函数顺序了解，但中间还有一些函数还需要掌握 Q4：多个设备的样式如何保持一致，字体的适配方式 不太了解 Q5：一段文字内不同的颜色怎么处理，字体超长在中间打点应该怎么做 没有了解过，可以去了解，超长打点跟style有关 Q6：物理的返回键了解过吗怎么使用，在flatList内不同的items怎么渲染 物理返回键不太了解，不同items直接放入data内也可以渲染，可以去看更好的方式 Q7：setState的代码问题 四次log输出的日志分别是多少 提醒点： setState()涉及到UI更新时是否立刻执行？（异步还是同步执行？） 执行setState不都是异步的。当没有前置batchedUpdate时，setState立马生效( 同步 )；当存在前置batchedUpdate时，setState会先放在'缓存'中，等到某时刻再执行( 异步 ) 前两次 setState 并不是失效，而是他们被 batch update 了，可以被理解为两次 setState 被缓存了，因此没有立即生效。所以第 2 次 log 的时候，val 还是 0。但是在第 3 次调 this.setState 时，前两次被「缓存」的 setState 已经执行，因为两次 setState 实际上都是 this.setState({val: 1})，所以第 3 次 setState 时的 val 是 1，且因为在setTimeOut中，setState会立即生效，因此第四次的setState时接收的val为3，打印的日志为3 结果为0,0,2,3  Q8：props和state的区别，函数组件和类组件的区别，hooks，自定义hooks 基本回答上，自定义hooks可以使用高级组件（HOC）实现，可以了解 Q9：flatList与其他滑动组件的区别，flex布局的一些属性，margin和padding的区别 了解flatList和ScrollView的区别，flatList的渲染数量问题 ## 后续学习进展"},{"title":"Android Studio模拟器安装APK问题","date":"2022-09-02T15:41:44.642Z","url":"/SmartBoyMB.github.io/2022/09/02/Android%20Studio%20problem/","tags":[["客户端","/SmartBoyMB.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"],["problem","/SmartBoyMB.github.io/tags/problem/"]],"categories":[["Android Studio","/SmartBoyMB.github.io/categories/Android-Studio/"],["学习","/SmartBoyMB.github.io/categories/Android-Studio/%E5%AD%A6%E4%B9%A0/"]],"content":"启动adb失败： 问题描述： Failed to start adb. Check settings to verify your chosen adb path is valid. 问题原因： sdk/adb路径找不到导致adb启动失败。 解决方案： 按图示顺序设置ADB location，路径在%SDK/platform-tools/adb（SDK的路径在Android Studio SDK Manager中查看，一般是/Users/{HostName}/Library/Android）"},{"title":"TS基础知识","date":"2022-09-02T15:37:03.645Z","url":"/SmartBoyMB.github.io/2022/09/02/TS%E5%AD%A6%E4%B9%A0/","tags":[["基础知识","/SmartBoyMB.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"categories":[["TypeScript","/SmartBoyMB.github.io/categories/TypeScript/"],["学习","/SmartBoyMB.github.io/categories/TypeScript/%E5%AD%A6%E4%B9%A0/"]],"content":"JS数据类型 类型标注 类型的标注主要通过类型后置语法来实现：“变量：类型” 接口的作用就是为类型命名和为代码或第三方代码定义契约 类 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类 模块导入和导出 任何声明（比如变量，函数，类，类型别名或接口）都能够添加export关键字导出（使用as可以给声明导出为别名） 使用import对模块进行导入，也可以通过as重命名 核心配置文件 总结 数据类型 TypeScript 包含的数据类型： * any(任意类型)： 声明为 any 的变量可以赋予任意类型的值。 * number(数字类型)： 双精度 64 位浮点值。它可以用来表示整数和分数。 * string(字符串类型)： 一个字符系列，使用单引号（'）或双引号（&quot;）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式。 * boolean(布尔类型)： 表示逻辑值：true 和 false。 * 数组类型(Array): 声明变量为数组。 * 元组(Tuple): 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。 * 枚举(enum): 枚举类型用于定义数值集合。 * void: 用于标识方法返回值的类型，表示该方法没有返回值。 * null: 表示对象值缺失。 undefined: 用于初始化变量为一个未定义的值 never: never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。 与JS的比较 对于JS来说，TS严格定义了数据的类型，并且做了一些改进和划分，但也兼容了JS的松散定义。 新增 any any类型即为任意的类型。针对编程时类型不明确的变量使用的一种数据类型，应用于三种情况： 变量的值会动态改变时，例如来自用户的输入。 改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查 定义存储各种类型数据的数组时，例如any[] 改进 string 增加了反引号（`）来定义多行文本和内嵌表达式。 数组类型分类 JS中的数组规范宽松，TS重新分类定义了数组类型： * 数组类型： 声明变量为数组，同种元素的集合，不能包含不同类型的元素。 两种声明方式： * number [ ] （类型 + [ ]） * Array （范型 * 元组类型： 元组类型可以包含不一样的类型元素，但需要严格按照定义好的类型顺序和元素数量赋值。 声明方式： * [string, number] * push()和pop()方法 * 枚举类型： 枚举类型用于定义数值集合，可以定义初始递增值。 * 数字类型枚举： * 字符串类型枚举： ### never类型 never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环） 例子： ### TS中的循环 TypeScript还支持 for... of、 forEach、every 和 some 循环。以及其他方法的详细的描述 * for ... of｜for ... in: 常用于遍历对象和数组： for... in 循环读取键名 for... of 循环读取键值 forEach(): 常用于遍历数组和操作数组： forEach遍历没有返回值，需要返回值则可以使用every和some forEach不能遍历对象，遍历对象使用for方法。 every()|some(): 常用于遍历数组和操作数组： 两种方法都不能遍历对象，遍历对象可以使用for方法。 方法与forEach类似，但包含返回值（true/false），false会终止迭代器。 some(): 返回一个boolean，判断是否有元素是否符合func条件。数组里面所有的元素有一个符合条件就返回true。 every():返回一个boolean，判断每个元素是否符合func条件。数组里面所有的元素都符合才返回true。 every()和some()都通过控制return的值来跳出循环。 every方法最终返回值为true需要每一次回调函数返回值都为true，当遍历出现返回false时，就会终止后续的遍历。 some方法最终返回值为true只需要任意一次回调函数返回值为true就会结束对数组的遍历，如果每一次回调函数返回值都为false的话则some方法就会一直遍历辖区并返回false TS函数 基础格式 参数 可选参数：在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。注意：可选参数一定要放在必选参数后，必选参数一定要放在可选参数前。 默认参数：也可以设置参数的默认值，这样在调用函数的时候，如果不传入该参数的值，则使用默认参数。注意：参数不能同时设置为可选和默认。 剩余参数：不知道要向函数传入多少个参数时可以用剩余参数定义，不确定数量的参数作为一个数组传入，参数名以 ... 为前缀。(...出现在函数调用或类似函数中时，它被称为“扩展运算符”并将数组扩展为 list.) ### 匿名函数 没有函数名，可以赋值给一个变量，也可以定义后自调用。 其他 Number对象 属性 MAX_VALUE： 可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 &quot;Infinity&quot;。 MIN_VALUE： 可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (&quot;underflow values&quot;) 的值将会转换为 0。 NaN： 非数字值（Not-A-Number）。 NEGATIVE_INFINITY： 负无穷大，溢出时返回该值。该值小于 MIN_VALUE。（-Infinity） POSITIVE_INFINITY： 正无穷大，溢出时返回该值。该值大于 MAX_VALUE。（Infinity） 方法 toExponential() 把对象的值转换为指数计数法 toFixed() 把数字转换为字符串，并对小数点指定位数 toLocalString() 把数字转换为字符串，使用本地数字格式顺序 toPrecision() 把数字格式化为指定长度，遵循四舍五入原则。 toString() 把数字转换为字符串，使用指定的进制数2-36 valueOf() 返回Number对象的数字值 ## TS数组 ### 数组方法 concat(): 连接两个或更多的数组，并返回结果。 every(): 检测数值元素的每个元素是否都符合条件。 filter(): 检测数值元素，并返回符合条件所有元素的数组。 forEach(): 数组每个元素都执行一次回调函数。 indexOf(): 搜索数组中的元素，并返回它所在的位置。 如果搜索不到，返回值 -1，代表没有此项 join(): 把数组的所有元素放入一个字符串 lastIndexOf(): 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 map(): 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop(): 删除数组的最后一个元素并返回删除的元素。 push(): 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce(): 将数组元素计算为一个值（从左到右）。 reduceRight(): 将数组元素计算为一个值（从右到左）。 reverse(): 反转数组的元素顺序。 shift(): 删除并返回数组的第一个元素。 slice(): 选取数组的的一部分，并返回一个新数组。 some(): 检测数组元素中是否有元素符合指定条件。 sort(): 对数组的元素进行排序。 splice(): 从数组中添加或删除元素。 toString(): 把数组转换为字符串，并返回结果。 unshift(): 向数组的开头添加一个或更多元素，并返回新的长度。 数组结构 TS Map 存储键/值对的对象。.ts文件需要使用es6编译 (tsc --target es6 test.ts) ### Map的属性和方法： * clear(): 移除Map对象的所有键/值对。 set() 设置键/值对，返回该Map对象。 get() 返回对应键的值，不存在则返回undefined。 has() 返回一个布尔值，用于判断Map中是否有包含键的对应值。 delete() 删除Map中的元素，删除成功则返回true，否则返回false。 size() 返回Map对象存储的键/值对的数量。 keys() 返回一个Iterator对象，包含了 Map 对象中每个元素的键 。 values() 返回一个新的Iterator对象，包含了Map对象中每个元素的值 。 TS 联合类型 联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。 注意：只能赋值指定的类型，如果赋值其它类型就会报错。（函数表达式也是一种类型） 格式：Type1|Type2|Type3 ### type type 修饰符可以创造类型的别名： keyof keyof 可以返回一个接口，或者类内的属性的联合类型。 TS修饰符 randonly 含义，用于修饰属性。它能让你以一种更安全的方式工作（不可预期的改变是很糟糕的） ### 与const 的比较 | const | randonly | |:----:|:----:| | 用于变量 | 用于属性| |变量不能赋值给其他任何事物|用于别名，可以修改属性| readonly 能确保“我”不能修改属性，但是当你把这个属性交给其他并没有这种保证的使用者（允许出于类型兼容性的原因），他们能改变它。当然，如果使用者明确的表示，他们的参数不可修改，那么编译器会发出错误警告： ## TS面向对象 ### 类与接口的区别 |类|接口| |---|---| |class作为TS的一种变量类型存在于上下文之中，class中可以提供，变量、方法等的具体实现方式等，它的作用不仅仅是约束数据结构。|存于TS上下文中的一种虚拟结构，TS编译器依赖接口进行类型检查，编译成JS后，接口会被移除。只定义变量和方法的声明，不能有具体的实现。个人理解：可以理解为一种特殊的数据类型，只用来约束数据的结构，直接约束对象，和其他语言内的有区别。| |使用class约束数据结构性能差，因为会编译成JS代码。|使用interface约束数据结构性能好，因为不会被编译成JS代码。| |当需要使用class时，我通常会考虑三个方面：(1)是否需要创建多个实例;(2)是否需要使用继承;(3)是否需要特定的单例对象。| 对于从服务器端获取或者业务场景中模拟的数据，提倡使用interface去定义，这些数据通常是不会经常变化和调整的，这些数据可能仅仅只表示某些状态，或者是UI上的文本。| 鸭子类型(Duck Typing) 鸭子类型（英语：duck typing）是动态类型的一种风格，是多态(polymorphism)的一种形式。 在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由&quot;当前方法和属性的集合&quot;决定。 个人理解:是一种程序设计理念，就是不需要去限定相同的类型，而是能具有需要使用的属性和方法即可允许。 ## TS 命名空间 命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。 TypeScript 中命名空间使用 namespace 来定义，语法格式如下： 同个命名空间在不同ts文件下要使用需要加上注释： /// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt; 代码实例： ### 嵌套命名空间 TS模块 TypeScript 模块的设计理念是可以更换的组织代码。 模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。 两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。 模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。此外还有有 SystemJs 和 Webpack。所以在tsc -m 选项下可以选择使用不同的模块加载器。 跨越模块调用： ## TS声明文件 TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。 个人理解：为了调用系统库内描述JS的方法时，让方法能被TS识别，通过TS的参数检测。 ### 声明文件格式 * 文件以 .d.ts 结尾 * 语法格式: * 当然，很多流行的第三方库的声明文件不需要我们定义了，比如jQuery就已经定义好了："},{"title":"JS基础知识","date":"2022-09-02T15:37:03.576Z","url":"/SmartBoyMB.github.io/2022/09/02/JS%E5%AD%A6%E4%B9%A0/","tags":[["基础知识","/SmartBoyMB.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"categories":[["JavaScript","/SmartBoyMB.github.io/categories/JavaScript/"],["学习","/SmartBoyMB.github.io/categories/JavaScript/%E5%AD%A6%E4%B9%A0/"]],"content":"JS数据类型 1 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol、BigInt。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。 注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 变量的数据类型可以使用 typeof 操作符来查看。 JS的浮点数运算是不精确的。 JS的正则 语法：/正则表达式主体/修饰符(可选) 例子：var patt = /runoob/i 2 方法： search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法用于在字符串中用一替换另一些字符串，或替换一个与正则表达式匹配的子串。 test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 exec() 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 JS 闭包 私有变量可以使用到闭包 例子： 变量add指定了函数自我调用的返回字值。自我调用函数只执行一次。 设置计数器为 0。并返回函数表达式。add变量可以作为一个函数使用。 非常棒的部分是它可以访问函数上一层作用域的计数器。 这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。 计数器受匿名函数的作用域保护，只能通过add方法修改。 闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。 直观的说就是形成一个不销毁的栈环境。 JS函数 bind()：Function.prototype.bind() 语法：function.bind(thisArg[, arg1[, arg2[, ...]]]) （参数thisArg即函数调用时this的绑定值，参数args则是函数调用时的参数绑定值） 参数 thisArg: 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。 arg1, arg2, ...： 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。 返回值 返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。 例子： ### 如何不使用bind() 你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。 这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick=&#123;this.handleClick&#125;，你应该为这个方法绑定 this。 如果使用 bind 让你很烦，这里有两种方式可以解决。如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数： 如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数： 使用这个语法有个问题就是每次 LoggingButton 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。 JS数组(Array) 数组对象的作用是：使用单独的变量名来存储一系列的值。 数组可以通过索引访问和修改，例如： 数组中的对象可以是不同类型，例如： 数组的属性 | 属性 | 描述 | |:---:|:---:| |constructor|返回创建数组对象的原型函数（函数的引用| |length|设置或返回数组元素的个数| |prototype|允许你向数组类（数组类内）添加属性或方法 语法：Array.prototype.name=value| 数组的方法（常用的，后续学习到继续补充） 方法 描述 concat() 连接两个或更多的数组，并返回结果 indexOf() 搜索数组中的元素并返回所在的位置 fill() 用一个指定的值填充数组 push() 向数组的末尾添加一个或更多元素，返回新的长度 slice() 选取数组的一部分，并返回一个新的数组 sort() 数组排序 map() 通过指定的函数处理数组中的每个元素，并返回处理后的数组 isArray() 判断是否为数组 JS DOM 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM模型被构造为对象的树： 找到HTML元素。有三种方法来做这件事： 通过 id 找到 HTML 元素：var x=document.getElementById(&quot;intro&quot;); 通过标签名找到 HTML 元素：var y=x.getElementsByTagName(&quot;p&quot;); 通过类名找到 HTML 元素：var x=document.getElementsByClassName(&quot;intro&quot;); JS DOM事件 onload 和 onunload 事件： onload 和 onunload 事件会在用户进入或离开页面时被触发。 onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。 onload 和 onunload 事件可用于处理 cookie。 onchange 事件 onchange 事件常结合对输入字段的验证来使用。 当用户改变输入字段的内容时，会调用指定的函数。 onmouseover 和 onmouseout 事件 onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 onmousedown、onmouseup 以及 onclick 事件 onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。 DOM与Refs Refs 提供了一种访问在 render 方法中创建的 DOM 节点或 React 元素的方法。 在典型的 React 数据流中，props是父组件与其子组件交互的唯一方式。要修改一个孩子，你可以用新的道具重新渲染它。但是，在某些情况下，您需要在典型数据流之外强制修改子项。要修改的子元素可以是 React 组件的实例，也可以是 DOM 元素。 创建Refs 以下示例已更新为使用React.createRef()React 16.3 中引入的 API。如果您使用的是早期版本的 React，我们建议使用回调 refs。 React.createRef() Refs 是使用属性创建React.createRef()并附加到 React 元素的。refRefs 通常在构建组件时分配给实例属性，以便可以在整个组件中引用它们。 回调 React 还支持另一种设置 refs 的方法，称为“回调 refs”，它可以更细粒度地控制何时设置和取消设置 refs。 不是传递由ref创建的属性createRef()，而是传递一个函数。该函数接收 React 组件实例或 HTML DOM 元素作为其参数，可以在其他地方存储和访问。 #### 访问Refs 当 ref 被传递给 render 中的元素时，对节点的引用可以在 ref 的current属性处访问。 const node = this.myRef.current; Ref 的值因节点的类型而异： 当在 HTML 元素上使用 ref 属性时，使用 React.createRef() 在构造函数中创建的 ref 接收底层 DOM 元素作为其当前属性。 当 ref 属性用于自定义类组件时，ref 对象接收组件的已安装实例作为其当前实例。 你不能在函数组件上使用 ref 属性，因为它们没有实例。 下面的示例演示了这些差异。 DOM组件中使用Ref 此代码使用 ref 来存储对 DOM 节点的引用： #### 类组件中使用Ref 如果我们想包装上面的 CustomTextInput 以模拟它在安装后立即被点击，我们可以使用 ref 来访问自定义输入并手动调用其 focusTextInput 方法 #### 函数组件中使用Ref 如果你想让人们把一个ref组件带到你的函数中，你可以使用forwardRef（结合useImperativeHandle），或者你可以将组件转换为一个类。 但是，只要您引用 DOM 元素或类组件，您就可以在函数组件中使用该属性：ref #### 将DOM Refs暴露给父组件 在极少数情况下，您可能希望从父组件访问子组件的 DOM 节点。通常不建议这样做，因为它会破坏组件封装，但它有时对触发焦点或测量子 DOM 节点的大小或位置很有用。 虽然您可以向子组件添加 ref，但这不是一个理想的解决方案，因为您只会获得组件实例而不是 DOM 节点。此外，这不适用于功能组件。 如果您使用 React 16.3 或更高版本，我们建议在这些情况下使用ref 转发（forwardRef）。Ref 转发允许组件选择将任何子组件的 ref 公开为它们自己的 ref。您可以在 ref 转发文档中找到有关如何将子 DOM 节点公开给父组件的详细示例。 ## JS BOM 浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器&quot;对话&quot;。 Window 对象 所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 甚至 HTML DOM 的 document 也是 window 对象的属性之一： window.document.getElementById(&quot;header&quot;); 与此相同： document.getElementById(&quot;header&quot;); 方法和方法 window.innerHeight - 浏览器窗口的内部高度(包括滚动条) window.innerWidth - 浏览器窗口的内部宽度(包括滚动条) window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 Window Screen window.screen对象在编写时可以不使用 window 这个前缀。 一些属性： screen.availWidth - 可用的屏幕宽度 screen.availHeight - 可用的屏幕高度 Window Location window.location 对象在编写时可不使用 window 这个前缀 location.hostname 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http: 或 https:） Window History window.history对象在编写时可不使用 window 这个前缀。 为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制。 一些方法： history.back() - 与在浏览器点击后退按钮相同 history.forward() - 与在浏览器中点击向前按钮相同 Window Navigator window.navigator 对象包含有关访问者浏览器的信息。 window.navigator 对象在编写时可不使用 window 这个前缀。 JS 进阶 JS 对象 JavaScript 中的所有事物都是对象：字符串、数值、数组、函数...。此外，JavaScript 允许自定义对象。 ### 创建对象 通过 JavaScript，您能够定义并创建自己的对象。 创建新对象有两种不同的方法： 使用 Object 定义并创建对象的实例。 使用函数来定义对象，然后创建新的对象实例。 使用字面量创建对象。（var obj={ }）。 使用类创建对象。 JavaScript 基于 prototype，而不是基于类的。 ES6之后类其实在底层还是使用了 JavaScript 的函数和原型链。 所以尽量不使用。 使用对象 在 JavaScript 中，几乎所有的对象都是 Object 类型的实例，它们都会从 Object.prototype 继承属性和方法。 Object 构造函数创建一个对象包装器。 Object 构造函数，会根据给定的参数创建对象，具体有以下情况： 如果给定值是 null 或 undefined，将会创建并返回一个空对象。 如果传进去的是一个基本类型的值，则会构造其包装类型的对象。 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址。 当以非构造函数形式被调用时，Object 的行为等同于 new Object()。(例如 var num=Object(1))。 ### 使用函数作为对象构造器 可以在函数内定义对象的属性和方法： 原型对象 每一个javascript对象(除null外)创建的时候，都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。 prototype 在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。（ps：函数其实也是一个对象） 所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 通过prototype添加属性和方法 ### proto __proto__是实例（引用类型）指向原型的属性。prototype是对象或者构造函数指向原型的属性。 ### Constructor 每个原型都有一个constructor属性，指向该关联的构造函数。 ### 原型链 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这样就形成了原型链。 结构图 拓展原型链 该Object.create()方法创建一个新对象，使用现有对象作为新创建对象的原型。 ## 异步编程 Promise Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 使用+then方法 其他方法 all方法： 与then同级的另一个方法，all方法，该方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后并且执行结果都是成功的时候才执行回调。 race方法 all是等所有的异步操作都执行完了再执行then方法，那么race方法就是相反的，谁先执行完成就先执行回调。先执行完的不管是进行了race的成功回调还是失败回调，其余的将不会再进入race的任何回调。 #### all方法结果： #### race方法结果： "},{"title":"MachineLearning","date":"2021-05-10T05:08:10.000Z","url":"/SmartBoyMB.github.io/2021/05/10/MachineLearning/","tags":[["机器学习","/SmartBoyMB.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"机器学习的分类 监督学习分类 回归（regression）和分类（classification）。 在回归问题中，我们会预测一个连续值。也就是说我们试图将输入变量和输出用一个连续函数对应起来；比如通过房地产市场的数据，预测一个给定面积的房屋的价格就是一个回归问题。这里我们可以把价格看成是面积的函数，它是一个连续的输出值。而在分类问题中，我们会预测一个离散值，我们试图将输入变量与离散的类别对应起来。比如：给定医学数据，通过肿瘤的大小来预测该肿瘤是恶性瘤还是良性瘤(课程中给的是乳腺癌的例子)，这就是一个分类问题，它的输出是0或者1两个离散的值。(0代表良性，1代表恶性)。分类问题的输出可以多于两个，比如在该例子中可以有{0,1,2,3}四种输出，分别对应{良性, 第一类肿瘤, 第二类肿瘤, 第三类肿瘤}。 无监督学习 在无监督学习中，我们基本上不知道结果会是什么样子，但我们可以通过聚类的方式从数据中提取一个特殊的 结构。在无监督学习中给定的数据是和监督学习中给定的数据是不一样的。在无监督学习中给定的数据没有任 何标签或者说只有同一种标签。GAN就是一种无监督学习 无监督学习与监督学习的区别 有监督学习方法必须要有训练集与测试样本。在训练集中找规律，而对测试样本使用这种规律。而非监督学习没有训练集，只有一组数据，在该组数据集内寻找规律。 有监督学习的方法就是识别事物，识别的结果表现在给待识别数据加上了标签。因此训练样本集必须由带标签的样本组成。而非监督学习方法只有要分析的数据集的本身，预先没有什么标签。如果发现数据集呈现某种聚集性，则可按自然的聚集性分类，但不予以某种预先分类标签对上号为目的。 非监督学习方法在寻找数据集中的规律性，这种规律性并不一定要达到划分数据集的目的，也就是说不一定要“分类”。 半监督学习 所给的数据有的是有标签的，而有的是没有标签的。常见的两种半监督的学习方式是直推学习（Transductive learning）和归纳学习（Inductive learning）。 直推学习（Transductive learning）：没有标记的数据是测试数据，这个时候可以用test的数据进行训练。这里需要注意，这里只是用了test数据中的feature而没有用label，所以并不是一种欺骗的方法。 归纳学习（Inductive learning）：没有标签的数据不是测试集。 迁移学习 随着越来越多的机器学习应用场景的出现，而现有表现比较好的监督学习需要大量的标注数据，标注数据是一项枯燥无味且花费巨大的任务，所以迁移学习受到越来越多的关注。Transfer Learning 的定义是：Ability of a system to recognize and apply knowledge and skills learned in previous domains/tasks to novel domains/tasks。将某个领域或任务上学习到的知识或模式应用到不同但相关的领域或问题中为目标。 增强学习（reinforcement learning） reinforcement learning的特点: agent是从环境中去学习,不是data中，是基于环境的,angent需要从环境中获得大量的信息来学习和采取行动action，目标是学习从环境状态到行为的映射，使得agent选择的行为能够获得环境最大的奖励，reinforcement learning中的奖励来自于环境中的反馈。 强化学习的关键要素有：environment，reward，action 和 state。有了这些要素我们就能建立一个强化学习模型。强化学习解决的问题是，针对一个具体问题得到一个最优的policy，使得在该策略下获得的reward最大。所谓的policy其实就是一系列action。也就是sequential data。 强化学习可用下图来刻画，都是要先从要完成的任务提取一个环境，从中抽象出状态(state) 、动作(action)、以及执行该动作所接受的瞬时奖赏(reward)。"},{"title":"pythonLearning","date":"2020-11-21T12:40:54.000Z","url":"/SmartBoyMB.github.io/2020/11/21/pythonLearning/","tags":[["python","/SmartBoyMB.github.io/tags/python/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"import 和 from ... import 的区别 import导入的文件，在引用内部类或者函数时，仍然需要标注文件名。 from...import导入的文件，在引用时可不需要标注文件名。 未完待续"},{"title":"long tail Relation","date":"2020-11-06T04:45:19.754Z","url":"/SmartBoyMB.github.io/2020/11/06/longtailrelation/","tags":[["知识图谱","/SmartBoyMB.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"],["概念","/SmartBoyMB.github.io/tags/%E6%A6%82%E5%BF%B5/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"“long tail”的含义 根据维基百科，长尾（The Long Tail）这一概念是由“连线”杂志主编Chris Anderson在2004年十月的“长尾” 一文中最早提出，用来描述诸如亚马逊和Netflix之类网站的商业和经济模式。 “长尾”实际上是统计学中Power Laws和帕累托（Pareto）分布特征的一个口语化表达。 在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的，因此又称二八定律。 举例来说，我们常用的汉字实际上不多，但因出现频次高，所以这些为数不多的汉字占据了上图广大的红区；绝大部分的汉字难得一用，它们就属于那长长的黄尾。 “long tail”的理解 假设一个坐标轴以每个实体所具有的三元组数为横轴，以具有该三元组数实体的计数为纵轴，由于只有少量的实体具有较多数量的三元组，大多数实体具有的三元组数量较少，所以坐标轴会呈现一种随着三元组数增加，实体计数越来越少的现象，并且三元组数少的实体占比较大，呈现长尾的形态，这些实体被称为长尾实体。也可以用我们常说的二八定律来解释。 "},{"title":"少样本知识图谱推理","date":"2020-11-04T12:52:30.853Z","url":"/SmartBoyMB.github.io/2020/11/04/xiaoyangbenzhishitupu/","tags":[["知识图谱","/SmartBoyMB.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"],["论文学习","/SmartBoyMB.github.io/tags/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"摘要 早先的对于知识图谱（KGs）的研究中对于每种关系通常要求大量的训练用例。然而，我们发现长尾关系（long-tail relations）在知识图谱（KGs）中更加的普遍并且这些新添加的关系通常没有使用太多的已知三元组训练。 在这项工作中，我们的目标是在一个具有挑战性的环境下预测新的事实，其中只有一个培训实例可用。 在这项工作中，我们的目标是在一个具有挑战性的环境下预测新的事实，其中只有一个培训实例可用。 我们提出了一种次关系学习框架，它利用嵌入模型提取的知识，并通过考虑学习的嵌入和一跳图结构来学习匹配度量。我们的模型比现有的嵌入模型产生了相当大的性能改进，并且在处理新增加的关系时也不需要重新训练嵌入模型。 研究介绍 Large-scale knowledge graphs(Suchanek et al.,2007; Vrandeˇci´c and Kr¨otzsch, 2014; Bollacker et al., 2008; Auer et al., 2007; Carlson et al., 2010)将每一条信息表示为实体之间的二进制关系，通常以三元组的形式表示。 （主语，谓语，宾语）。 这种结构化知识对于许多下游应用程序(如问答和语义Web)是必不可少的。 Despite KGs’ large scale, they are known to be highly incomplete (Min et al., 2013). To automat\u0002ically complete KGs, extensive research efforts (Nickel et al., 2011; Bordes et al., 2013; Yang et al., 2014; Trouillon et al., 2016; Lao and Cohen, 2010; Neelakantan et al., 2015; Xiong et al.,2017; Das et al., 2017; Chen et al., 2018) 已经建立了关系学习模型，可以通过从现有的学习来推断缺失的三元组。 这些方法探索三元组或路径模式的统计信息，以推断现有关系的新事实；并在各种公共数据集上取得了相当大的性能。 然而，这些数据集(例如:以前的模型使用的FB15k，WN18)大多只涵盖KGS中的公共关系。对于更实际的场景，我们认为所需的KG完成模型应该处理KG的两个关键属性。 KG关系的很大一部分实际上是长尾关系。换句话说，它们的实例很少。但从直觉上看，一个关系的训练三元组越少，KG完成技术就越有用。因此，模型能够以有限的三元组完成关系是至关重要的。 为了捕捉最新的知识，现实世界的KGS通常在任何特定的时刻都是动态的和进化的。适应新关系的能力对于当前模型也是有限的。 与以往的方法相比，我们提出了一个只依赖于实体嵌入和局部图结构的模型。我们的模型旨在学习一个匹配的度量，可以用来发现更多相似的三元组，给定一个参考三元组。可学习度量模型是基于一个置换不变网络，它有效地编码实体的one-hop邻居，也是一个允许多步匹配的递归神经网络。一旦训练，模型将能够对任何关系进行预测，而现有的方法通常需要微调以适应新的关系。通过两个新构建的数据集，我们证明了我们的模型可以在一次链路预测任务上实现对各种嵌入模型的一致改进。 总之，我们的贡献有三个方面： 我们是第一个考虑链路预测任务中的长尾关系，并将问题描述为少镜头关系学习。 我们提出了一个有效的关系数据一次性学习框架，比各种基于嵌入的方法获得了更好的性能。 我们还为one-shot知识的任务提供了两个新构造的数据集。 相关工作 嵌入关系学习模型（Embedding Models for Relational Learning） 参考的一些模型 RESCAL (Nickel et al., 2011)算法：基于张量分解的算法。 Antoine Bordes, Nicolas Usunier, Alberto GarciaDuran, Jason Weston, and Oksana Yakhnenko.2013. Translating embeddings for modeling multirelational data.：提出了一维矢量空间中的关系建模方法。 DistMult (Yang et al., 2014)，ComplEx (Trouillon et al., 2016) and ConvE (Dettmers et al., 2017)： 已经被提出了。这些基于嵌入的模型通常为所有关系和实体假设足够的训练实例，并且不注意这些稀疏符号。 Baoxu Shi and Tim Weninger. 2017. Open-world knowledge graph completion.：已经被建议通过利用文本描述来处理看不见的实体。 与这些方法相比，我们的模型处理长尾关系或新添加的关系，并侧重于一次关系学习，没有任何外部信息，如实体或关系的文本描述。 少样本学习（Few-Shot Learning） 最近基于深度学习的少镜头学习方法分为两大类： 基于度量的方法：它试图从一组训练任务中学习可推广的度量和相应的匹配函数。这类方法大多采用深层孪生网络（Siamese network）中提出的通用匹配框架。 基于元学习的方法：它的目的是学习模型参数的优化（通过输出参数更新或直接预测模型参数），给出了几个例子的梯度。一个例子是基于LSTM的元学习器，它学习随机梯度的每个维度的步长。 除了上述类别之外，还有一些其他风格的少镜头学习算法，例如：贝叶斯程序归纳，它将概念表示为简单的程序，在贝叶斯准则下最好地解释观察到的例子。 以往的少样本学习研究主要集中在视觉和模仿学习领域。在语言领域，也提出了一种基于多指标的文本分类方法。据我们所知，这项工作是关于知识图的少样本学习的第一项研究。 背景 问题构想 知识图G表示为三元组，当和分别为实体序列和关系序列。 知识图完成的任务是预测在两个实例之间看不见的关系：或者在给予头部实体和查询关系的情况下预测尾部实体：。由于我们的目的是为新增加的或现有的长尾关系推断看不见的事实，我们将重点放在后一种情况上。与以前的工作相比，通常假设查询关系有足够的三元组可用于培训，本工作研究的情况是只有一个培训三元组可用。 更具体的说，对于真正的尾部实体的排列是要高于其他候选实体，对于唯一给定的一个三元组例子。候选集是使用实体类型约束构造的。同样值得注意的是，当我们预测关系的新事实时，我们只考虑一组封闭的实体。换句话说，测试期间没有未见的实体。对于在测试过程中可能出现新实体的开放世界设置，通常需要外部信息，如关于这些实体的文本描述，我们将此留给今后的工作。 一次学习设定 我们工作的目的是学习一个度量，可以用来预测新的事实与一个热门的例子。遵循标准的一次性学习设置。我们假设访问一组培训任务。 在我们的问题中，每个训练任务对应一个KG关系，并有自己的培训/测试三元组：。此任务集通常表示为元训练集，。 在模拟评估时的一次预测，只有一个三元组在每个。由的测试三元组和对于每个查询真实标签尾部实体。以及相应的尾部实体候选人，其中每个是中一个实体。因此，通过排列由测试查询和在中的标记三元组得到的候选人序列，这个度量模型可以被测试在这个序列。 我们表示一个任意排序损失函数表示为，代表的是我们度量模型的参数。这个损失函数表示了度量模型在元组如何，同时观察来自的仅一次数据。这个训练度量模型的目标，换句话说，元训练的目的，因此成为 是从元训练集中采样的，并且表明为的元组数。 一旦训练，我们就可以使用模型对新关系进行预测，这被称为文献中的元测试步骤。这些元测试关系是在元训练中看不见的，换句话说，。每个元测试关系也有自己的一次训练数据和测试数据，定义方式与元训练相同。这些元测试关系形成了一个元测试集。 此外，我们在训练中省略了一个关系子集，元验证集。 由于一次学习的假设，元测试关系没有像传统的机器学习设置那样的验证集。否则，度量模型实际上会在元测试期间看到多个一次标记数据，因此会违反了一次假设。 最终，我们假定一个方法可以访问背景知识图谱(background knowledge graph)，这是一个删除了,,和所有联系的的子集 模型 这一节，描述了一个提出的相似度量学习模型，以及相应的用于训练模型的损失函数。 提出模型的核心是相似度量函数。因此对于任意的查阅关系，只要有一个已知的事实(h_0,r,t_0)，这个模型就可以跟根据每个和之间的匹配分数才预测测试三元组的可能性。上述匹配功能的实现涉及两个子问题： 实体对的表示。 两个实体对表示之间的比较函数。 我们整体模型，如图1所示： Neighbor encoder 目的是利用局部图结构更好地表示实体。这样，模型可以利用KG为实体对中的每个实体提供的更多信息，增强每个实体在知识图中的本地连接的表示。 显示建模的结构模式，如路径，通常有利于关系预测。鉴于此，我们建议使用邻居编码器将图形结构纳入我们的度量学习模型。 为了从结构信息中受益，同时保持效率，以方便地扩展到现实世界的大规模KGS，我们的邻居编码器只考虑实体的本地连接，即，一跳邻居(one-hop neighbors)。 对于给定的实体，其本地连接形成一组（关系、实体）元组。如图1中（a）所示，对于实体Leonardo da Vinci，这样的元组之一是（职业，画家）。我们将此邻居集称为。 我们的邻居编码器的目的是编码并输出一个向量作为的潜在表示。由于这是一个大小不同的编码集的问题，我们希望编码函数能够（1)对排列不变，(2）对邻居集的大小不敏感。 我们使用满足上述性质的下列函数： 其中是关系实体对的特征表示，是激活函数。在文章中，设置了，在上验证得到了最好的性能。 将编码到中，首先使用维数为d的嵌入层emb（可以使用现有的基于嵌入的模型进行预训练）来获得和的向量表示： Dropout应用于向量，以实现更好的泛化。然后，我们应用前馈层（feed-forward layer）编码这个元组中的交互。 其中是要学习的参数并且代表连接。 由于我们在实体的闭集上工作，我们通过考虑背景知识中的实体与出现在、或中的实体之间的交集来绘制这个数字。 请注意，、或中的所有三元组都从中删除。 上：NELL；下：Wikidata。 为了在训练期间启用批处理，我们手动指定最大邻居数，并使用全零向量作为“虚拟”邻居。 虽然不同的实体有不同的程度（邻居的数量），但程度分布通常非常集中，如图2所示。 我们可以很容易地找到一个适当的界，作为批处理实体组的最大邻居数。 在这里提出的邻居编码器模块类似于关系图卷积网络(Schlichtkrull等人，2017年)，因为我们还使用共享内核{WC，BC}对不同实体的邻居进行编码。但与它们在整个图上工作并执行多个信息传播步骤的模型不同，我们只对实体的局部图进行编码并执行一步传播。这使我们能够轻松地将我们的模型应用于大规模的KGS，如Wikidata。此外，它们的模型也不适用于预先训练的图形嵌入。我们留下对其他图形编码策略的研究，例如。(Xu等人，2018年；Song等人，2018年)，给今后的工作。 Matching Processor 给定邻居编码器模块，现在我们讨论如何基于递归匹配处理器进行有效的相似性匹配。通过将应用于引用实体对和任何查询实体对，我们获得了每个实体对的邻居向量：。为了得到一个相似分数，可以用来在其他候选中进行排序，，我们可以简单地将每个对中的和连接起来，形成一个单对表示向量，并计算对之间的余弦相似度。 然而，这个简单的度量模型结果太浅，没有给出良好的性能。为了扩大我们的模型的容量，我们利用一个基于LSTM的(Hochreiter和Schmidhuber，1997)递归“处理”块(Vinyals等人，2015，2016)来执行多步匹配。每个流程步骤定义如下： 是一个具有输入，隐藏状态和单元状态的标准LSTM单元，并且是引用对和查询对的级联邻居向量。在个处理步骤之后，我们使用作为查询和支持实体对之间的最终相似性评分。每一个查询，通过比较，和，，我们可以得到每个的排名分数。 Loss Function and Training 对于查询关系及其引用/训练三元组，，，我们收集了一组正（真）查询三元组，，，，，并通过污染尾部实体构造了另一组负（假）查询三元组，，，，，根据以前基于嵌入的模型，我们使用铰链损失函数来优化我们的模型： 其中，和通过使用我们的度量模型将查询三元组，，与参考三元组，，进行比较来计算的标量，并且margin γ是要调整的超参数。对于每个训练集，我们首先从元训练集中采样一个任务/相关。然后，从中的所有已知三元组中，我们抽样了一个三元组作为参考/训练三元组，并抽样了一批其他三元组作为正向查询/测试三元组。训练过程的细节如图3算法1所示。 实验 数据集 其中，#Ent表示唯一实体的数目，#R表示所有关系的数目，#Tasks表示我们作为一次性任务使用的关系数。 现有的知识图完成基准，如FB15k-237 (Toutanova et al.,2015) and YAGO3-10 (Mahdisoltani et al., 2013)都是真实世界KGS的小子集。这些数据集在训练和测试期间考虑了相同的关系集，并且通常为每个关系包含足够的训练三元组。为了构建一次学习的数据集，我们回到原始的KGS，并选择那些没有太多三元组的关系作为一次任务关系。 我们将其余的关系称为背景关系，因为它们的三元组为我们匹配实体对提供了重要的背景知识。 第一个数据集是基于 NELL (Mitchell et al., 2018)，这是一个通过浏览网页不断收集结构化知识的系统。我们采取最新的转储(dump)和删除这些反关系。我们选择小于500但超过50三元组的关系作为一次任务。为了证明我们的模型能够在大规模的KGS上操作，我们遵循类似的过程来构建另一个基于Wikidata的更大的数据集(Vrandeˇci´c and Kr¨otzsch, 2014). 数据集统计如表所示.请注意，Wiki-One数据集在实体和三元组的数量上比任何其他基准数据集大一个数量级。对于NELL-One，我们使用51/5/11任务关系进行培训/验证/测试。对于WikiOne，除法比是133：16：34。 实现细节 在我们的实验中，我们考虑了以下基于嵌入的方法：RESCAL(Nickel等人，2011年)、TransE(Bordes等人，2013年)、DistMult(Yang等人，2014年)和Complex(Trouillon等人，2016年)。对于TransE，我们使用Lin等人发布的代码(2015年b)。对于其他模型，我们已经尝试了Trouillon等人发布的代码(2016)。但在我们的数据集上，它给出的结果比TransE差得多。因此，我们使用了基于PyTorch的实现作为比较(Paszke等人，2017年)。在评估现有的嵌入模型时，在训练过程中，我们不仅使用背景关系的三元组，而且使用训练关系的所有三元组和这些Validation/test系的一次训练三元组。 然而，由于所提出的度量模型不需要嵌入查询关系，所以我们只包括嵌入训练的背景关系的三元组。由于TransE和DistMult使用一维向量来表示实体和关系，它们可以直接用于我们的模型。对于RESCAL，由于它使用矩阵来表示关系，所以我们在这些矩阵上使用平均池来获得一维嵌入。对于COMPLEX模型，我们使用实部和虚部的级联。我们模型的超参数在验证任务集上进行了调优，可以在附录中找到。 除了上述嵌入模型外，最近的一种方法(Dettmers等人，2017年)将卷积应用于模型关系，并在几个基准上获得最佳性能。对于每个查询，他们的模型列举了整个实体集，以获得正三元组和负三元组进行训练。我们发现，这种训练范式在处理大型实体集时需要大量的计算资源，不能扩展到具有数百万实体的Wikidata等现实世界的KGs。对于可伸缩性问题，我们的实验只考虑使用负抽样进行训练的模型。 结果 我们的方法的主要结果如上图所示。我们将我们的方法表示为“GMatching”，因为我们的模型被训练成匹配局部图形模式。我们使用平均倒数秩(MRR)和Hits@K来评估不同的模型。我们可以看到，我们的方法在这些一次关系上的各种嵌入模型上产生了一致的改进。在更大的Wiki-One数据集上，这些改进甚至更有实质性。为了研究模型的学习能力，我们还尝试用随机初始化的嵌入来训练我们的度量模型。令人惊讶的是，虽然结果比具有预先训练嵌入的度量模型差，但它们仍然优于基线嵌入模型。这表明，通过将邻居实体纳入我们的模型，许多关系和实体的嵌入实际上得到了有效的更新，并为我们的模型对测试数据进行预测提供了有用的信息。 值得注意的是，一旦经过训练，我们的模型可以用来预测任何新添加的关系，而不需要微调，而现有的模型通常需要重新训练来处理那些新添加的符号。在一个大的现实世界KG上，这个再训练过程可能是缓慢的，并且计算成本很高。 Remark on Model Selection 鉴于各种KG嵌入模型的存在，一个有趣的实验是将模型选择纳入超参数调优，并选择最佳的验证模型进行测试。如果我们考虑将KG嵌入和度量学习作为两种方法进行比较，那么模型选择过程的结果就可以作为比较的“最终”度量。例如，基线KG嵌入在Wiki-One上以RESCAL（11.9%）获得了最佳的MRR，因此我们报告了相应的测试MRR（7.2%）作为KG嵌入方法的最终模型选择结果。这样，在图5的上半部分，我们根据验证性能选择最佳的KG嵌入方法。重点突出了结果。同样，我们在底部选择最佳度量学习方法。从这个角度来看，我们的基于度量的方法也比KG嵌入有很大的优势。以MRR为例，所选择的度量模型在NELL-One上达到17.1%，在Wiki-One上达到20.0%，而KG嵌入的结果为9.3%和7.2%。改善分别为7.8%和12.8。 Analysis on Neighbor-Encoder 当我们的模型通过编码邻居来利用实体的局部图结构时，这里我们试图通过限制邻居的最大数量来研究邻居集的影响。 如果真邻居集的大小大于最大限制，则通过随机抽样选择邻居。图7上图显示了不同设置的学习曲线。 这些曲线是基于验证集上计算的Hits@10。对于每个实体来说，通常都会导致更好的性能。 我们还观察到，以最大值编码40个邻居的模型实际上比只编码30个邻居的模型产生更差的性能。 我们认为潜在的原因是，对于某些实体对，存在一些不相关的局部连接，并向模型提供噪声信息。我们看到对于每个实体来说，编码更多的邻居通常都会导致更好的性能。我们还观察到，以最大值编码40个邻居的模型实际上比只编码30个邻居的模型产生更差的性能。我们认为潜在的原因是，对于某些实体对，存在一些不相关的局部连接，并向模型提供噪声信息。 Ablation Studies 我们使用在NELL-One数据集上实现最佳Hits@10的模型进行消融研究。结果见图7下图的表。我们在验证和测试集上使用Hits@10进行比较，因为超参数是使用这个评估度量来选择的。 我们可以看到，匹配处理器和邻居编码器在我们的模型中都扮演着重要的角色。 另一个重要的观察是，缩放因子对邻居编码器非常重要。没有缩放，邻居编码器实际上比简单的基于嵌入的匹配给出更差的结果。 Performance on Different Relations 在测试各种模型时，我们观察到不同关系的结果实际上具有很高的方差。图6显示了由我们的最佳度量模型(GMatching-ComplEx)生成的NELL-One的分解结果及其相应的嵌入方法。作为参考，我们还报告了嵌入模型在标准训练设置下的性能，其中75%的三元组（而不是只有一个）用于训练，其余的用于测试。我们可以看到，与较小的候选集的关系通常更容易，我们的模型甚至可以比在标准设置下训练的嵌入模型表现得更好。对于一些关系，如运动员伤害他的身体部分，他们所涉及的实体在KG中很少有联系。正如预期的那样，一次性学习这些关系是相当具有挑战性的。这些与许多（&gt;3000）候选人的关系对所有模型都是具有挑战性的。即使对于具有更多训练三元组的嵌入模型，在某些关系上的性能仍然非常有限。这说明知识图完成任务还远未解决。 结论 本文介绍了一种一次性关系学习框架，可用于预测KGs长尾关系的新事实。我们的模型利用实体的局部图结构，并学习一个可微度量来匹配实体对。与通常需要微调以适应新关系的现有方法相比，我们的训练模型可以直接用于预测任何看不见的关系，并且在一次射击设置中也获得了更好的性能。我们今后的工作可能会考虑纳入外部文本数据，并加强我们的模型，以便更好地利用少数镜头学习案例中的多个培训示例。"},{"title":"hexo 主题使用mathjax插件渲染LaTeX数学公式的问题","date":"2020-11-04T09:26:46.889Z","url":"/SmartBoyMB.github.io/2020/11/04/howtosetmathjax/","tags":[["hexo","/SmartBoyMB.github.io/tags/hexo/"],["blog","/SmartBoyMB.github.io/tags/blog/"],["mathjax","/SmartBoyMB.github.io/tags/mathjax/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"使用hexo为主题配置mathjax渲染LaTex数学公式 hexo本身并不支持LaTex格式的数学公式的渲染，一般都是通过mathjax插件来实现的，我查阅了很多资料，大部分都是针对于NEXT主题的一个设置，或者安装hexo-math工具包，以及手动配置mathjax.js等策略，很多都是复制粘贴，甚至代码都有错误。但经过实际操作，忙活了两天后，我分享一下我实现的方法。 使用hexo-filter-mathjax代替hexo-math 其实直接使用hexo-math是可以直接对公式进行渲染的，hexo-math通过标签插件将KaTeX和MathJax嵌入到Hexo帖子/页面中，方程在Hexo（服务器端）中呈现，因此不需要浏览器端javascript库，应将其删除，CSS样式是默认包含的。具体方法参考 但是不可避免，语法上hexo-math对于KaTeX和MathJax是分别使用下面两种格式的。 这与我们常使用的LaTex语法不同，并且更加复杂。所以用hexo-filter-mathjax插件可以直接编写LaTex语句。关于hexo-filter-mathjax插件安装与设置的具体方法参照 解决Hexo与MathJax渲染冲突问题 添加MathJax后，出现了部分渲染失败的问题，尤其是对有下划线'_'的公式。这是由于Hexo默认使用hexo-renderer-marked引擎渲染MarkDown，再交给MathjaX渲染，hexo-renderer-marked会吧一些特殊的markdown符号转换成相应的html标签，比如在markdown语法中，下划线_代表斜体，会被转化为&lt;em&gt;标签,所以MathJax引擎在渲染数学公式的时候就会出错。 在这里有人使用了hexo-renderer-kramed引擎替代，但我没有做尝试，而是使用了hexo-renderer-pandoc替代，他可以将Pandoc的markdown转换为HTML。 首先要确保安装了Pandoc，因为该渲染器是基于Pandoc上运行的。安装包下载地址为 安装完后运行下述的两个命令卸载hexo-renderer-marked和安装hexo-renderer-pandoc 其他的配置请参考地址"},{"title":"知识图谱学习（二）","date":"2020-10-27T08:35:16.510Z","url":"/SmartBoyMB.github.io/2020/10/27/kglearning2/","tags":[["知识图谱","/SmartBoyMB.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"],["概念","/SmartBoyMB.github.io/tags/%E6%A6%82%E5%BF%B5/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"知识表示 知识应用的难点在于知识推理，知识推理的难点在于知识表示。知识表示是基于知识的人工智能应用中的核心部分。 知识表示的五个主要角色： 知识表示是一种代理，基于对事物的表示，我们无需实践而是通过思考和推理就可以得到有关外部世界的结论。 知识表示是一组本体论约定的集合，说明我们以什么样的方式来思考世界。 知识表示是只能推理的组成部分；推理需要知识进行表示，但知识表示不是推理的全部。 知识表示是高效计算的媒介；通过对知识进行有效组织，支持高效的推理。 知识表示是人类表达的媒介；基于通用表示框架，方便人们表达和分享对世界的认识。 基于五个角色，将从三个层次介绍各种知识表示方法。 人工智能和知识工程中的经典知识表示理论：逻辑、语义网络、框架、脚本。 语义网中的知识表示方法。 知识图谱中的知识表示方法以及在大数据环境下面向具体应用的知识图谱的数值化知识表示方法。 经典知识表示理论 逻辑 逻辑本身根据复杂性从简单到复杂分为：命题逻辑、一阶谓词逻辑、高阶逻辑。 命题逻辑与谓词逻辑区别：谓词逻辑存在量词，可以通过量词实现对对象集合的描述。两种量词：全称量词、存在量词。 语义网络 语义网络是一个通过语义关系连接的概念网络，它将知识表示为相互连接的点和边的模式。节点表示实体、事件、值等，边表示对象之间的语义关系。也就是说，语义网其实是一种有向图表示的知识系统，节点代表概念，而边则表示这些概念之间的语义关系。语义网络中最基本的单元称为语义基元，可以用三元组表示 &lt;节点1，关系，节点2 &gt;。 语义网络中的关系类型： （1）实例关系（ISA）：体现的是“具体与抽象”的概念，含义是“是一个”，表示一个事物是另个一个事物的一个实例。（类似于类的实例化） （2）分类关系（AKO）:亦称泛化关系，体现的是“子类与超类”的概念，含义为“是一种”，表示一个事物是另一个事物的一种类型。（类似于类的继承） （3）成员关系：体现的是“个体与集体”的关系，含义为“是一员”。表示一个事物是另一个事物的成员。（类似于类的组合） （4）属性关系：指事物和其属性之间的关系。常用的属性关系有： Have：含义为“有”，表示一个节点具有另一个节点所描述的属性。 Can：含义为“能”、“会”，表示一个节点能做另一个节点的事情。 （5）聚合关系：亦称包含关系，指具有组织或结构特征的“部分与整体”之间的关系。 （6）时间关系：指不同时间在其发生时间方面的先后次序关系。（时间上） （7）位置关系：指不同事物在位置方面的关系。（空间上） （8）相近关系：指不同事物在形状、内容等方面相似或接近。 可以按照论元个数把关系分为一元关系、二元关系和多元关系。 语义网络与一阶谓词具有相同的表达能力，不同的是，它用最简单的一种统一形式描述所有知识，非常有利于计算机的存储和检索。 语义网络的缺点是，它仅用节点及其关系描述知识，推理过程不像谓词逻辑表示方法那样明了，需要针对不同关系做不同处理，推理方法还不完善。 框架 框架将所有事物进行抽象，并用来表示事物各方面的属性以及事物之间的类属关系。 框架定义了这些概念的实例应该或可能具备的属性，这些属性被称为槽。若存在一个实体，就需要对教师框架中的槽或部分槽进行值的填充。 在原始的框架定义中，槽可以是任何形式的信息，包括原子值或值的集合；对于非原子的槽，还可以由多个侧面（facet）对槽的描述进行补充，这样做的目的是更立体准确地描述事物的属性与关系。 框架引入了层级结构，并根据类别之间的所属与细化，框架中的属性集合存在着继承的性质。 框架以强大的结构式表达能力和接近人类思维过程的特性，被应用与多个领域装甲系统的构建以及通用知识的表达。但框架表示法也有不可避免的缺陷，由于真实世界的多样性和复杂性，许多实际情况与框架原型存在较大的差异，在框架设计中难免引入错误或冲突。另外因为框架结构的复杂性，一方面，不同系统之间的框架很难对齐，另一方面，也给从非结构文本中抽取信息填充框架增加难度。 脚本 脚本通过一系列的原子动作来表示事物的基本行为，按照时间顺序描述事物的发生，类似于电影剧本。脚本表示的知识有确定的时间或因果顺序，必须是前一个动作完成后才会触发下一个动作的开始。与框架相比，脚本是用来描述一个动态过程而非静态知识的的表示方法。 一个完整的脚本应该包括以下几个重要的组成部分： 进入条件：指出脚本所描述的时间可能发生的先决条件，即事件发生的前提条件。 角色：描述事件中可能出现的人物。 道具：描述事件中可能出现的相关物体，主要指任务角色在完成动作时使用的工具。 舞台：脚本中事件发生的空间。 场景：时间发生的序列 结局：给出剧本所描述的时间发生以后通常所产生的结果，对应着进入后续脚本的先决条件。 脚本的表示能力有限，部剧本对元素基本属性的描述能力，也难以描述多变的时间发展可能方向。但在非常狭小的领域内，脚本表示方法却可以比其他方法更细致地刻画步骤和时序关系。 综上，经典知识表示理论中的语义网络、框架和脚本都属于基于槽的表示方法，有所区别的是槽是否具有层次、时序、控制关系。 语义网中的知识表示方法 语义网表示方法 语义网（Semantic Web）与人工智能中提出的语义网络（Semantic Network）的概念有所不同。 传统万维网中HTML文档的表示与语义网概念下XML格式文档表示的对比。语义网中，标签不再仅仅是网页格式的标志，而是含有自身的语义。 语义网知识描述体系 目前，语义网知识表示体系主要包括如下三个层次： XML：全称可扩展标记语言。 RDF：全称资源描述框架。RDF可以看成XML的扩展或简化。 OWL：全称网络本体语言。OWL是本体语义表示语言，建立在RDF和RDF Schema的基础之上。 知识图谱中的知识表示方法 表示框架 通常情况下，一个知识本体主要涵盖以下几个方面的内容： 事物：客观世界中的实体或对象。 概念：具有相似本体特征的一类事物，也称类型。 属性：事物或概念具有的特征和特性等。 关系：概念与实体之间的关联关系。 函数：事物或概念之间进行转化的形式表达。 约束：某项断言成立的限制条件的形式化描述。 规则：依据某项断言得到逻辑推论的因果关系知识的形式化描述。 公理：永远为真的断言。 狭义的知识图谱可以看成是知识库的图结构表示。以下介绍的知识图谱局限在现存的具有图有图结构的三元组知识库上，泛指三元组知识组成的有向图结构。 知识图谱的知识表示绝不仅仅体现在以RDF为基础框架的三元组之上，还体现在实体、类别、属性、关系等多颗粒度、多层次语义单元的关联之中，它是一个知识系统，以一种统一的方式表示了知识定义（Schema）和知识实例（Instance）两个层次的知识。 知识图谱的数值化表示方法 符号的数值化表示 知识表示的一大重要目标就是进行语义计算。 显式表示的知识，难以获取更全面的知识特征，另一方面，目前的大多数语义计算任务都采用基于数值计算的统计机器学习方法，而作为知识载体的数据表示是机器学习中的基础工作，数据表示的好坏直接影响到整个机器学习系统的性能。 文本的数值化表示 词是知识表示的最基本的单元，词的语义由上下文决定。 这种上下文分布表示词义的方法，并将这种表示用于词义消歧等任务，这类方法在当是被称为词空间模型。 2006年后，神经网络构造词表示的方法可以更灵活地对上下文进行建模，这类方法开始逐渐成为了词分布表示的主流方法。 知识图谱的数值化表示 表示学习也是知识图谱研究的热点任务之一，它把知识图谱中的离散符号（实体、属性、关系、值等）用连续型数值进行表示，这种表示能够体现实体和关系的语义信息，可以高效地计算实体、关系及其之间的复杂语义关联。 知识图谱表示学习的主要方法有张量分解模型和基于能量函数的模型等，它们都有各自的学习方式。 基于张量分解的表示学习方法 张量分解以RESCAL系统为代表，核心思想是将整个知识图谱编码为一个三维张量,如果三元组存在于知识图谱中，则对应张量中的值为1，否则为0。将张量分解为核心张量和因子矩阵的乘积形式，其中核心张量中每个二维矩阵切片代表一种关系的语义，因子矩阵中每一列代表一个实体的向量。模型重构的结果中的每一个元素被看做对应三元组成立的概率，如果概率大于某个阈值时，该三元组即为推断出的正确三元组。张量分解在编码实体和关系的过程中综合了整个知识图谱的信息，它的主要缺点是需要优化张量中所有位置的值，包括0在内。。因此，当关系数目较多时，张量的维度很高，分解过程计算量较大。 基于能量函数的表示学习方法 基于能量函数模型的方法是当前知识图谱表示学习研究最为丰富的方法，该类方法可以克服上述张量分解方法在大规模知识图谱表示学习过程学习效率低的问题。对于三元组，定义基于三元组的能量函数。如，TransE模型中能量函数定义为，和分别表示实体和关系的向量表示。记知识图谱中三元组的集合为,表示由生成的负样本的集合（比如，随机替换或），学习的目标函数定义为 其中是分离正样本和负样本的边界值。该目标函数的原理是使正样本的能量比负样本的能量低，通过惩罚负样本的能量值完成学习过程。 在测试的过程中，每种关系都设置一个能量阈值，如果三元组的能量小于阈值，则是正确的，否则不正确。因此，推理过程即使计算三元组能量的过程，当三元组能量值小于阈值时，该三元组为推断出的新三元组。不同能量模型的区别在于能量函数的构造不同。"},{"title":"知识图谱学习（一）","date":"2020-10-26T03:04:42.933Z","url":"/SmartBoyMB.github.io/2020/10/26/KnowledgeGraphLearning1/","tags":[["知识图谱","/SmartBoyMB.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"],["概念","/SmartBoyMB.github.io/tags/%E6%A6%82%E5%BF%B5/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"知识图谱学习 这里将介绍有关知识图谱学习的第一部分，主要是知识图谱的一个概述。 知识的定义 陈述性知识（描述性知识） 描述客观事物的性状等静态信息，主要分为事物、概念、命题三个层次。 事物：特定的事和物。 概念：对一类事物本质特性的反映。 （3）命题 对事物之间的陈述。分为非概括性命题和概括性命题。 非概括性命题：特定的事物之间的关系。 概括性命题：概念之间的普遍关系。 过程性知识（程序性知识） 描述问题如何求解等动态信息，分为规则和控制结构两种类型。 规则：描述事物的因果关系。 控制结构：描述问题的求解步骤。 知识图谱的定义 图是一种能有效表示数据之间结构的表达形式，因此，人们考虑把数据中蕴含的知识用图的结构进行形式化表示。数据的结构化并和以后的结构化数据进行关联，就构成了知识图谱。 知识和结构化数据的表示和存储 在计算机科学领域，对知识和结构化数据的表示和存储具有不同的技术路线，最典型的包括本体（Ontology）和数据库（Database）两类。 本体 在人工只能领域，本体是通过对象类型、属性类型以及关系类型对领域知识进行形式化描述的模型。本体强调抽象的概念表示，因此只对数据的定义进行了描述，而没有描述具体的实例数据。 数据库 数据库是计算机科学家为了电脑表示和存储计算机应用中需要的数据而设计开发的产品。不同类型的数据库（关系数据库、面向对象数据库、非关系型数据库等），一般用于存储数据，这些数据可以进行传递和交换。数据库对于数据的描述和数据本身的操作提供了不同的描述语言，因此我们认为，数据库系统对数据描述和数据记录的表示和存储采用了不同的机制。 知识图谱的数据描述 实际上，人工智能应用中不仅需要具体的知识实例数据，数据的描述和定义也非常关键，例如概念上下位知识（‘大熊猫’是一种‘熊科动物’）、属性之间的关系（‘子女’与‘父母’是逆关系）、属性的约束（一个‘人’的‘父母’只有‘2个’）等。 知识图谱用统一的形式对知识实例数据的定义和具体知识数据进行描述，即用三元组形式（二元关系）对知识系统进行资源描述和存储。例如：WIkidata中不仅用&lt;Max Planck, instance of ,human&gt;表达具体的实例数据，也用&lt;place of birth, value type constraint, geographical object&gt;等三元组对相关知识结构进行了描述。 实例数据只有在满足系统约定的‘框架’约束下运用才能体现为‘知识’，其中“框架”（Schema或元知识）就是对知识的描述和定义，知识框架和实例数据共同构成一个完整的知识系统。 知识图谱以结构化三元组的形式存储现实世界中的实体以及实体之间的关系，表示为$ g=(,R,S) \\(,其中\\)={e_1,e_2,,e_(||)}\\(表示实体集合，\\)R={r_1,r_2,,r_(|R|)}\\(表示关系集合，\\)SR$表示知识图谱中三元组的集合。三元组通常描述了一个特定领域中的事实，由头实体、尾实体和描述这两个实体之间的关系组成。 尽管目前大部分知识图谱都以三元组的形式表示各种类型的知识，但是实际上知识图谱的知识表示绝不仅仅体现在以二元关系为基础的三元组上，还体现在实体、类别、属性、关系等多颗粒度、多层次语义单元的关联之中， 它以一种统一的方式体现知识定义（Schema）和知识实例（Instance）两个层次共同构成的知识系统。 知识框架 知识图谱应该包含哪些知识目前还没有统一定论。从知识工程的角度，知识框架一般包含了三个层次的知识： 概念知识：给出了知识的最基本内容。 事实知识：建立了概念之间的联系。 规则知识：建立了事物之间的联系。 综上，知识图谱以丰富的语义表示能力和灵活的结构构件了计算机世界中表示认知世界和物理世界中信息和知识的有效载体，成为人工智能应用的重要基础设施。 知识图谱类型 知识的类型（不同划分） 根据知识的主客观性，可以把知识分为事实性（或客观性）知识和主观性知识。 事实性知识: 通常是指那些确定性的。不随状态的变化而改变的知识，例如：“中华人民共和国的首都是北京”。 主观性知识：通常指某个人或群体的情感信息，例如：“大部分人都觉得苹果手机太贵了”这句话包含了用户对于苹果手机的意见和态度，但是这一态度会随着评论者的变化而变化。 根据知识变化的性质，已有的知识可以分为静态知识和动态知识。 静态知识：不随时间、空间的变化而变化，例如“生日”。 动态知识：随时间、空间的变化而变化的知识，例如“美国总统”。事件是动态知识的重要组成部分。 除此之外，我们也可以吧只是分为领域知识、百科知识、场景知识、语言知识、常识知识等等。 知识图谱的划分 已有的知识图谱根据领域和用途大致分为语言知识图谱、语言认识知识图谱、常识知识图谱、领域知识图谱以及百科知识图谱等几个类别。 对几个代表性的知识图谱简单介绍： Cyc Cyc是一个通用的常识数据库。 始建于1984年，其目的是将上百万条知识编码为机器可处理的形式，并在其基础上实现知识推理等智能信息处理任务。 主要由人工构建，包含50万实体，接近3万个关系以及500万事实。 用一阶谓词对知识进行描述，表达能力受限。 包含用于推理的常识规则，并提供多种推理引擎，支持演绎推理和归纳推理，同时也提供扩展推理机制的模块。 WordNet 一个英文电子词典和本体，将英文单词按照单词语义组成一个大的概念网络。 1985年由Princeton大学公布的一个英文电子词典和本体。 词语被聚类成同义词集。 知网（HowNet） 一个语言认知知识库/常识知识库，一概念为中心，基于义原描述了概念与概念之间以及概念所具有的属性之间的关系，每一个概念可以由多种语言的词汇进行描述（主要为中文和英文）。 由董振东教授主持开发。 知网是一个知识系统，经过多年的发展，目前知网总共包含了800多个义原，11000个词语。 ConceptNet ConceptNet是一个开放的、多语言的知识图谱。 致力于帮助计算机理解人们日常使用的单词意义。 由大量概念以及描述它们之间关系的常识构成，支持多种语言，可以用自然语言处理多种人工智能应用。 知识图谱的生命周期 主要包括知识体系构建、知识获取、知识融合、知识存储、知识推理和知识应用等。 知识体系构建 知识体系构建，也称知识建模。语义网的核心是让计算机能够理解文档中的数据，以及数据和数据之间的语义关联关系，从而使得计算机可以更加自动化、智能化地处理这些信息。与以往涉及面较广，只介绍与知识图谱数据建模紧密相关的核心概念——资源描述框架（RDF），RDF的基本数据模型包括了三个对象类型： 资源：能够使用RDF表示的对象称之为资源，包括互联网上的实体、事件和概念等。 谓词：谓词主要描述资源本身的特征和资源之间的关系。每一个谓词可以定义元知识。 陈述：一条陈述包含三个部分，通常称之为RDF三元组&lt;主题（subject）,谓词（predicate），宾语（object）&gt;。主体是被描述的资源，谓词表示主体的属性，也可以表示主体与宾语之间的关系。 知识获取 知识获取的目标是从海量的文本数据中通过信息抽取的方式获取知识，其方法根据所处理数据源的不同而不同。 知识图谱中的主要数据来源有各种形式的结构化数据、半结构化数据和非结构化文本数据（纯文本）。 相比于结构化和半结构化数据、非结构化文本数据要丰富的多。因此需要进行文本信息抽取，包括如下基本任务。 实体识别：实体识别任务的目标是从文本中识别实体信息。 实体消歧：实体消歧任务的目标是消除指定实体的歧义。 关系抽取：关系抽取的目标是获得两个实体之间的语义关系（可以是一元，二元，甚至更高元的关系）。 事件抽取：实践任务的目标是从描述事件信息的文本中抽取出用户感兴趣的事件信息并以结构化的的形式呈现出来。 知识融合 从融合的对象上看，知识融合包括：知识体系的融合和实例的融合。 知识体系的融合就是两个或多个异构知识体系进行融合，相同类别、属性、关系进行映射。 实例融合是对于两个不同知识图谱中的实例（实体实例，关系实例）进行融合，包括不同体系下的实例、不同语言的实例。 核心是计算两个知识图谱中的两个节点或边之间的语义映射关系。 从融合知识图谱类型上看，知识融合又分为：竖直方向的融合和水平方向的融合。 竖直方向的融合：指融合高层通用本体与底层领域本体或实例数据。 水平方向的融合：指融合同层次的知识图谱，实现实例数据的互补。 知识存储 目前知识图谱大多是基于图的数据结构，它的存储方式主要有两种形式：RDF格式存储和图数据库（Graph Database）。 RDF格式存储：就是以三元组的形式存储数据。不过由于逐行文本的存储使得搜索效率低下，为了提升三元组的搜索效率，通常采用六重索引的方法。 图数据库：比RDF数据库更加通用，目前典型的开源图数据库是Neo4j，这种图数据库的优点是具有完善的图查询语言，支持大多数图挖掘算法，它的缺点是数据更新慢，大节点的处理开销大。为了解决上述问题，子图筛选，子图同构判定等技术是目前图数据库的研究热点。 知识推理 由于处理数据的不完备性，所构建的知识图谱中肯定存在知识缺失现象（包括实体缺失、关系缺失） 由于数据的稀疏性，我们也很难利用抽取或者融合的方法对缺失的知识进行补齐。因此，需要采用推理的手段发现已有知识中的隐含的知识。 目前知识推理的研究主要集中在针对知识图谱中缺失关系的不足，即挖掘两个实体之间隐含的语义关系。所采用的的方法分为两种： 基于传统逻辑规则的方法进行推理：研究热点在于如何自动学习推理规则，以及如何解决推理过程中的规则冲突问题。 基于表示学习的推理：即采用学习的方式，将传统推理过程转化为基于分布式表示的语义向量相似度计算任务，这类方法的优点是容错率高、可学习，缺点也显而易见，即不可解释，缺乏语义约束。 当然，知识推理不仅应用于知识图谱的补全，也可以直接应用于相关应用任务。 知识应用 知识搜索：基于知识图谱的搜索引擎，可以根据用户查询准确地返回答案。用户意图理解是智能搜索的核心步骤。 自动问答：利用知识图谱中的实体及其关系进行推理得到答案。 推荐：利用知识图谱中的实体（商品）的关系（类别）向用户推荐相关的产品。 决策支持：知识图谱能够吧领域内的复杂知识通过信息抽取、数据挖掘、语义匹配、语义计算、知识推理等过程精确地描绘出来，并且可以描述知识的演化过程和发展规律，从而为研究和决策提供准确、可追踪、可解释、可推理的知识数据。 知识图谱与深度学习 基于数值计算的深度学习方法与基于符号表示和匹配的方法需要融合。 以下列举一些进展： 词的表示学习：是基于深度学习的自然语言处理方法的基础步骤，其主要目标是把每个词符号表示为分布向量的形式（Distributional Representation），基于词的向量表示，句子、段落、篇章、对话等更大的语言单元就可以通过语义组合模型（如卷积神经网络、循环神经网络等深度学习模型）得到，进而进行文本分类、问答匹配、机器翻译、对话生成等任务。 知识图谱表示学习：是将知识图谱中符号表示的实体和关系投影到低维向量空间中，这种表示能够体现实体和关系的语义信息，可以高效地计算实体、关系及其之间的复杂语义关联。 神经符号机：是一种将神经网络与符号推理相结合的技术，近年来开始被用于自然语言处理领域。神经符号机是利用神经网络对函数演算和图灵机等传统计算模型进行建模。根据抽象层次的不同，可以将其分为两类。一类为抽象层次较高，每个推理步骤都是从设计好的操作集合里选择，再选择合适的操作数，通过依次操作，得到最终答案。另一类的做法抽象层次较低，代表工作如神经图灵机、可微分神经计算机等，它们从模拟计算机底层操作方式的角度抽象模型，设计出内存、CPU控制器等结构，并借鉴传统计算机操作系统的思路，从随机访存、空闲内存分配、访存时序等不同侧面进行建模，完善模型的能力。 "},{"title":"LateXLearning","date":"2020-10-11T15:59:56.000Z","url":"/SmartBoyMB.github.io/2020/10/11/LateXLearning/","tags":[["LaTeX","/SmartBoyMB.github.io/tags/LaTeX/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"LaTex Learning Life 在这里我会记录一些在学习LaTeX工具过程中遇到的一些问题和坑。 编写伪代码 编写伪代码需要导入包algorithm、algorithmic、algpseudocode，但在实践中发现导入包algorithm后不要再导入algorithmic，否则会因为冲突报错，报错形式为Missing inserted。 符号用法 发现大部分人只回答大于等于号、小于等于号的写法，而没有说大于、小于号的分别写法。 （大于小于号并非公式规范内的写法，可写于公式外） 大于号： 小于号： （下面是公式内可以用的写法） 下面的后面要加空格，否则会识别错误 大于等于： 小于等于："},{"title":"Hello my blog life","date":"2020-10-09T11:06:06.000Z","url":"/SmartBoyMB.github.io/2020/10/09/Hellpmyblog/","tags":[["hexo","/SmartBoyMB.github.io/tags/hexo/"],["blog","/SmartBoyMB.github.io/tags/blog/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"start my blog life 从今天开始就开始编写自己blog来记录自己的学习经历啦！！！ token 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 ## 如何来搭建一个博客 首先我是基于github平台，使用Hexo工具来搭建我的个人博客的。在这里不详细的说明整个搭建的过程，网络上有非常多且详细的教程来指导博客的搭建，这篇博客主要是说明我搭建时的部分内容和遇到的难题。 这是我搭建时参考的视频教程： GitHub仓库的设置 在创建github仓库时，需要将仓库名命名为yourname.github.io，并且进入setting界面，下滑到GitHub Pages选项，设置source下的Branch为你博客部署的分支，并点击save保存。 GitHub测试访问博客时404问题 在设置好后，如果按照视频教程中通过仓库名作为网址（README文件内网址）测试访问博客网址，会出现页面404的问题。这个问题难为了我很久，查询了资料才发现这个问题出现在我们创建github账号以后，创建的github的博客域名和自己的账号不一样导致的。如果直接通过仓库名作为网址访问的话，博客域名和账号名字要一样，不然会404。但是，如果名字不一样，就需要通过setting界面下GitHub Pages选项下的site网址访问。 Hexo工具部署博客到GitHub参数设置问题 Hexo文档地址： 在部署时，_config.yml文件的一些参数设置 参数 描述 url setting界面下GitHub Pages选项下的site地址。 root /yourname.github.io/(两个斜杠不能去省略) deploy：type git（可以是其他方式) deploy：repo 仓库的git地址(也可以是其他方式的地址) deploy：branch 对应在setting界面，下滑到GitHub Pages选项，设置source下的Branch名称 主题的下载和设置 主题下载地址： 首先在该地址浏览找到自己喜欢的主题，并通过提供的github链接下载文件放置在Hexo工具创建的博客文件的themes文件夹下。下一步在_config.yml文件内改变themes的参数为新主题名。其他的设置参照给的thems内的README文件内的说明进行设置。"},{"title":"文档路径问题","date":"2020-10-09T11:06:06.000Z","url":"/SmartBoyMB.github.io/2020/10/09/Folderload/","tags":[["folder","/SmartBoyMB.github.io/tags/folder/"]],"categories":[["学习","/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"文档路径编写问题 “./”：代表目前所在的目录。与不加是一个效果 “…/”：代表上一层目录。 “/”：代表根目录。 例如，  URI 以一个 / 结尾，表示 folder 是一个目录，我们要访问的是这个目录下的文件，但是又没有说明是这个目录下的哪个文件，此时依然是采用该目录下 index.html 或者 default.html 一类的文件。 即 folder 后面没有 /，此时会先将 folder 当作一个资源去访问(比如一个名为 folder 的 Servlet )，如果没有名为 folder 的资源，那么浏览器会自动在 folder 后面加上一个 / 不加的话系统会有一个重定向的申请，可能会影响到request的一些功能。"}]