<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>沅湘</title>
  <meta name="author" content="Mei Biao" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="沅湘是清水">
<meta property="og:type" content="website">
<meta property="og:title" content="沅湘">
<meta property="og:url" content="https://github.com/SmartBoyMB.github.io/index.html">
<meta property="og:site_name" content="沅湘">
<meta property="og:description" content="沅湘是清水">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/SmartBoyMB.github.io/null">
<meta property="article:author" content="Mei Biao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/SmartBoyMB.github.io/null">
<meta name="twitter:site" content="@Candiinya">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="highlight-css" href="/css/highlight.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
<meta name="generator" content="Hexo 5.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/SmartBoyMB.github.io/atom.xml" title="沅湘" type="application/atom+xml">
</head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div>
            <header id="kratos-header-section">
                <div class="container">
                    <div class="nav-header">
                        <div class="color-logo"><a href="/">沅湘</a></div>
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/SmartBoyMB.github.io/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/SmartBoyMB.github.io/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://candinya.com">作者博客</a></li>
                                                    
                                                
                                                    
                                                        <li><a href="https://github.com/Candinya/Kratos-Rebirth">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/SmartBoyMB.github.io/">
                        <h2>沅湘</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div class="row">
                    
        <div id="main">
            
        <section class="col-md-8">
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="组件基础">组件基础</h1>
<h2 id="函数组件与class组件">函数组件与class组件</h2>
<p>你可以在 React 中使用函数式组件或 Class 组件。最开始只有 Class 组件能够使用 state ，但自从有了 React Hooks API, 你可以为函数组件添加 state 和很多其它的功能。</p>
<p>Hooks 是一种面向未来的编写 React 组件的方式。 ### 函数组件 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StyleSheet, Text, View&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YourApp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View style=&#123;styles.defaultStyle&#125;&gt;</span><br><span class="line">      &lt;Text&gt;Fuction Component&lt;/Text&gt;</span><br><span class="line">    &lt;/View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    justifyContent: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    alignItems: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> YourApp;</span><br></pre></td></tr></table></figure> ### class组件 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StyleSheet, Text, View&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.defaultStyle&#125;&gt;</span><br><span class="line">        &lt;Text&gt;Class Component&lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    justifyContent: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">    alignItems: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> YourApp;</span><br></pre></td></tr></table></figure> ## 核心组件 <a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/components-and-apis">详细API</a></p>
<p>React Native 具有许多核心组件，从表单控件到活动指示器，应有尽有。</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">React Native UI 组件</th>
<th style="text-align: center;">Android View</th>
<th style="text-align: center;">IOS View</th>
<th style="text-align: center;">Web analog</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">&lt;View&gt;</td>
<td style="text-align: center;">&lt;ViewGroup&gt;</td>
<td style="text-align: center;">&lt;UIView&gt;</td>
<td style="text-align: center;">&lt;div&gt; non-scrolling</td>
<td style="text-align: center;">一个支持带有 flexbox、样式、一些触摸处理和可访问性控件的布局的容器</td>
</tr>
<tr class="even">
<td style="text-align: center;">&lt;Text&gt;</td>
<td style="text-align: center;">&lt;TextView&gt;</td>
<td style="text-align: center;">&lt;UITextView&gt;</td>
<td style="text-align: center;">&lt;p&gt;</td>
<td style="text-align: center;">显示、样式和嵌套文本字符串，甚至处理触摸事件</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&lt;Image&gt;</td>
<td style="text-align: center;">&lt;ImageView&gt;</td>
<td style="text-align: center;">&lt;UIImageView&gt;</td>
<td style="text-align: center;">&lt;img&gt;</td>
<td style="text-align: center;">显示不同类型的图像</td>
</tr>
</tbody>
</table>
<p>|&lt;ScrollView&gt;|&lt;ScrollView&gt;|&lt;UIScrollView&gt;|&lt;div&gt;|可以包含多个组件和视图的通用滚动容器| |&lt;TextInput&gt;|&lt;EditText&gt;|&lt;UITextField&gt;|&lt;input type=&quot;text&quot;&gt;|允许用户输入文本|</p>
<h2 id="常用场景">常用场景</h2>
<h3 id="处理文本输入">处理文本输入</h3>
<p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/textinput#content">TextInput</a>是一个允许用户输入文本的基础组件。它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时被调用。另外还有一个名为onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用。 <img src="/images/React_native/基础组件-1.png" /></p>
<h3 id="滚动视图-scrollview组件">滚动视图 ScrollView组件</h3>
<p><strong>ScrollViews</strong>可以通过使用<strong>pagingEnabled</strong>属性来允许使用滑动手势对视图进行分页，在 Android 上也可以利用ViewPager组件水平滑动视图。</p>
<p>在 iOS 上包含单个子元素的 <strong>ScrollViews</strong> 可以允许用户对内容进行缩放. 通过设置<strong>maximumZoomScale</strong>和<strong>minimumZoomScale</strong>两者的属性, 您的用户能够利用捏合以及扩大手势来放大或缩小。</p>
<p><strong>ScrollView</strong>适合用来显示数量不多的滚动元素。放置在<strong>ScrollView</strong>中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外。如果你需要显示较长的滚动列表，那么应该使用功能差不多但性能更好的FlatList组件。</p>
<p><img src="/images/React_native/基础组件-2.png" /> ### 使用长列表 FlatList * <strong>FlatList</strong>组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。</p>
<ul>
<li><p><strong>FlatList</strong>更适于长列表数据，且元素个数可以增删。和<strong>ScrollView</strong>不同的是，<strong>FlatList</strong>并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p></li>
<li><p><strong>FlatList</strong>组件必须的两个属性是<strong>data</strong>和<strong>renderItem</strong>。<strong>data</strong>是列表的数据源，而<strong>renderItem</strong>则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。</p></li>
</ul>
<p><img src="/images/React_native/基础组件-2.png" /></p>
<h3 id="sectionlist组件">SectionList组件</h3>
<p>渲染一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。 <img src="/images/React_native/基础组件-3.png" /></p>
<h2 id="区分平台方法">区分平台方法</h2>
<h3 id="platform模块"><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/platform-specific-code#platform%E6%A8%A1%E5%9D%97">Platform模块</a></h3>
<p>React Native 提供了一个检测当前运行平台的模块。如果组件只有一小部分代码需要依据平台定制，那么这个模块就可以派上用场。 方法和属性： * <strong>Platform.OS</strong>: Platform.OS在 iOS 上会返回ios，而在 Android 设备或模拟器上则会返回android。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Platform, StyleSheet &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  height: Platform.OS === <span class="string">&#x27;ios&#x27;</span> ? <span class="number">200</span> : <span class="number">100</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> * <strong>Platform.select()</strong>: * 还有个实用的方法是 Platform.select()，它可以以 Platform.OS 为 key，从传入的对象中返回对应平台的值，见下面的示例代码会根据平台的不同返回不同的 container 样式 —— iOS 上背景色为红色，而 android 为蓝色。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Platform, StyleSheet &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    ...Platform.select(&#123;</span><br><span class="line">      ios: &#123;</span><br><span class="line">        backgroundColor: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      android: &#123;</span><br><span class="line">        backgroundColor: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> * 这一方法可以接受任何合法类型的参数，因此你也可以直接用它针对不同平台返回不同的组件: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = Platform.select(&#123;</span><br><span class="line">  ios: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;ComponentIOS&#x27;</span>),</span><br><span class="line">  android: <span class="function">() =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;ComponentAndroid&#x27;</span>)</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;Component /&gt;;</span><br></pre></td></tr></table></figure> * <strong>Platform.Version</strong>: * 在 Android 上，Version属性是一个数字，表示 Android 的 api level。</p>
<ul>
<li>在 iOS 上，Version属性是-[UIDevice systemVersion]的返回值，具体形式为一个表示当前系统版本的字符串。比如可能是&quot;10.3&quot;。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android</span></span><br><span class="line"><span class="keyword">import</span> &#123; Platform &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (Platform.Version === <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Running on Nougat!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ios</span></span><br><span class="line"><span class="keyword">import</span> &#123; Platform &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> majorVersionIOS = <span class="built_in">parseInt</span>(Platform.Version, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (majorVersionIOS &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Work around a change in behavior&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="特定平台扩展名">特定平台扩展名</h2>
<p>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native 会检测某个文件是否具有.ios.或是.android.的扩展名，然后根据当前运行的平台自动加载正确对应的文件。</p>
<p>文件名：</p>
<ul>
<li><p>BigButton.ios.js</p></li>
<li><p>BigButton.android.js</p></li>
<li><p>引用：import BigButton from './BigButton';</p></li>
</ul>
<p>如果你还希望在 web 端复用 React Native 的代码，那么还可以使用.native.js的扩展名。此时 iOS 和 Android 会使用BigButton.native.js文件，而 web 端会使用BigButton.js。（注意目前官方并没有直接提供 web 端的支持，请在社区搜索第三方方案）。</p>
<p>比如在你的项目中存在如下的两个文件:</p>
<ul>
<li><p>Container.js # 由 Webpack, Rollup 或者其他打包工具打包的文件</p></li>
<li><p>Container.native.js # 由 React Native 自带打包工具(Metro) 为ios和android 打包的文件</p></li>
</ul>
<p>在引用时并不需要添加.native.后缀:</p>
<ul>
<li>import Container from './Container';</li>
</ul>
<p>提示: 为避免在构建后的 Web 生产环境的代码中出现多余代码，要记得在你的 Web 打包工具中配置忽略.native.js结尾的文件, 这样可以减少打包后文件的大小</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="优化性能">优化性能</h1>
<p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/performance">官方文档</a></p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="页面导航">页面导航</h1>
<p><a target="_blank" rel="noopener" href="https://reactnavigation.org/docs/getting-started/">Navigation官方教程</a> 不同版本之间的使用差距比较大，具体版本具体分析。</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="网络通信">网络通信</h1>
<h2 id="使用fetch">使用Fetch</h2>
<p>React Native 提供了和 web 标准一致的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>，用于满足开发者访问网络的需求。</p>
<h2 id="发起请求">发起请求：</h2>
<p>要从任意地址获取内容的话，只需简单地将网址作为参数传递给 fetch 方法即可（fetch 这个词本身也就是获取的意思）： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单用例</span></span><br><span class="line"><span class="comment">//例子1</span></span><br><span class="line">fetch(<span class="string">&#x27;https://mywebsite.com/mydata.json&#x27;</span>);</span><br><span class="line"><span class="comment">//Fetch 还有可选的第二个参数，可以用来定制 HTTP 请求一些参数。</span></span><br><span class="line"><span class="comment">//你可以指定 header 参数，或是指定使用 POST 方法，又或是提交数据等等：</span></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line">fetch(<span class="string">&#x27;https://mywebsite.com/endpoint/&#x27;</span>, &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    firstParam: <span class="string">&#x27;yourValue&#x27;</span>,</span><br><span class="line">    secondParam: <span class="string">&#x27;yourOtherValue&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//例子3</span></span><br><span class="line">fetch(<span class="string">&#x27;https://mywebsite.com/endpoint/&#x27;</span>, &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="string">&#x27;key1=value1&amp;key2=value2&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> ## 处理响应： * 网络请求天然是一种异步操作（在等待期间运行其他程序），Fetch 方法会返回一个Promise，这种模式可以简化异步风格的代码；或者使用 ES2017 标准中的async/await 语法。</p>
<ul>
<li>别忘了 catch 住fetch可能抛出的异常，否则出错时你可能看不到任何提示。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise模式 then</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMoviesFromApiAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(</span><br><span class="line">    <span class="string">&#x27;https://facebook.github.io/react-native/movies.json&#x27;</span></span><br><span class="line">  )</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">responseJson</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> responseJson.movies;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在 React Native 应用中使用 ES2017 标准中的async/await 语法：</span></span><br><span class="line"><span class="comment">// 注意这个方法前面有async关键字</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMoviesFromApi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里的await语句，其所在的函数必须有async关键字声明</span></span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">&#x27;https://facebook.github.io/react-native/movies.json&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> responseJson = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="keyword">return</span> responseJson.movies;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 注意 &gt;默认情况下，iOS 会阻止所有 http 的请求，以督促开发者使用 https。如果你仍然需要使用 http 协议，那么首先需要添加一个 App Transport Security 的例外，详细可参考<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002933776">这篇帖子</a>。</li>
</ul>
<blockquote>
<p>从 Android9 开始，也会默认阻止 http 请求，请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40347548/article/details/86766932">相关配置</a></p>
</blockquote>
<h2 id="其他网络库">其他网络库</h2>
<p>React Native 中已经内置了<strong>XMLHttpRequest API</strong>(也就是俗称的 <strong>ajax</strong>)。一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如<strong>frisbee</strong>或是<strong>axios</strong>等。但注意不能使用 jQuery，因为 jQuery 中还使用了很多浏览器中才有而 RN 中没有的东西（所以也不是所有 web 中的 ajax 库都可以直接使用）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.onreadystatechange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>, request.responseText);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://mywebsite.com/endpoint/&#x27;</span>);</span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure></p>
<h2 id="基于websocket">基于WebSocket</h2>
<p>React Native还有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket</a>，这种协议可以支持在双TCP 连接上提供全工的通信信道。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://host.com/path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// connection opened</span></span><br><span class="line">  ws.send(<span class="string">&#x27;something&#x27;</span>); <span class="comment">// send a message</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// a message was received</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// an error occurred</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// connection closed</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.code, e.reason);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="相关链接">相关链接</h2>
<p>https://www.react-native.cn/docs/network#known-issues-with-fetch-and-cookie-based-authentication</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="手势交互">手势交互</h1>
<h2 id="处理触摸事件">处理触摸事件</h2>
<h3 id="button">Button</h3>
<p>简单的按钮，常用的属性方法是Color（调整颜色）和 onPress()（添加点击事件）。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">	color=<span class="string">&quot;blue&quot;</span>,</span><br><span class="line">  onPress=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    Alert.alert(<span class="string">&#x27;你点击了按钮！&#x27;</span>);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  title=<span class="string">&quot;点我！&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure> ### Touchable系列组件 Button组件的样式是固定的，所以如果它的外观并不怎么搭配你的设计，那就需要使用Touchable系列组件定制自己需要的样式。</p>
<ul>
<li><p><strong>TouchableHighlight</strong>：制作按钮或者链接，注意此组件的背景会在用户手指按下时变暗。</p></li>
<li><p><strong>TouchableNativeFeedback</strong>：（android）用户手指按下时形成类似墨水涟漪的视觉效果。</p></li>
<li><p><strong>TouchableOpacity</strong>：在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。</p></li>
<li><p><strong>TouchableWithoutFeedback</strong>：处理点击事件的同时不显示任何视觉反馈。</p></li>
<li><p>需要检测用户是否进行了长按操作。可以在上面列出的任意组件中使用onLongPress属性来实现。</p></li>
</ul>
<h3 id="动画">动画</h3>
<p>React Native 提供了两个互补的动画系统：用于创建精细的交互控制的动画<a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animations#animated-api">Animated</a>和用于全局的布局动画<a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animations#layoutanimation-api">LayoutAnimation</a>。</p>
<h4 id="animated">Animated</h4>
<p>使得开发者可以简洁地实现各种各样的动画和交互方式，并且具备极高的性能。</p>
<p>Animated旨在以声明的形式来定义动画的输入与输出，在其中建立一个可配置的变化函数，然后使用start/stop方法来控制动画按顺序执行。</p>
<p>Animated仅封装了 6 个可以动画化的组件：View、Text、Image、ScrollView、FlatList和SectionList，不过你也可以使用Animated.createAnimatedComponent()来封装你自己的组件。</p>
<h4 id="配置动画">配置动画</h4>
<p>Animated提供了三种动画类型。每种动画类型都提供了特定的函数曲线，用于控制动画值从初始值变化到最终值的变化过程：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#decay">Animated.decay()</a>以指定的初始速度开始变化，然后变化速度越来越慢直至停下。</p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#spring">Animated.spring()</a>提供了一个基础的弹簧物理模型.</p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#timing">Animated.timing()</a>使用easing 函数让数值随时间动起来。</p></li>
</ul>
<p>大多数情况下你应该使用timing()。默认情况下，它使用对称的 easeInOut 曲线，将对象逐渐加速到全速，然后通过逐渐减速停止结束。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timing方法定义</span></span><br><span class="line"><span class="keyword">static</span> timing(value, config)</span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line">Animated.timing(<span class="built_in">this</span>.state.xPosition, &#123;</span><br><span class="line">  toValue: <span class="number">100</span>, <span class="comment">//value到达的终点</span></span><br><span class="line">  easing: Easing.back(), <span class="comment">//Easing函数 ：</span></span><br><span class="line">  duration: <span class="number">2000</span> <span class="comment">//持续时间</span></span><br><span class="line">  delay: <span class="number">200</span> <span class="comment">//动画开始前的延迟时间</span></span><br><span class="line">  <span class="comment">//isInteraction: 指定本动画是否在InteractionManager的队列中注册以影响其任务调度。默认值为 true。</span></span><br><span class="line">  <span class="comment">//useNativeDriver: 启用原生动画驱动。默认不启用(false)。</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h2 id="组合动画">组合动画</h2>
<p>多个动画可以通过parallel（同时执行）、sequence（顺序执行）、stagger和delay来组合使用。它们中的每一个都接受一个要执行的动画数组，并且自动在适当的时候调用start/stop。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timing方法定义</span></span><br><span class="line"><span class="comment">//例子：动画滑行停止，然后在平行旋转的同时弹回:</span></span><br><span class="line">Animated.sequence([</span><br><span class="line">  <span class="comment">// decay, then spring to start and twirl</span></span><br><span class="line">  Animated.decay(position, &#123;</span><br><span class="line">    <span class="comment">// coast to a stop</span></span><br><span class="line">    velocity: &#123; <span class="attr">x</span>: gestureState.vx, <span class="attr">y</span>: gestureState.vy &#125;, <span class="comment">// velocity from gesture release</span></span><br><span class="line">    deceleration: <span class="number">0.997</span></span><br><span class="line">  &#125;),</span><br><span class="line">  Animated.parallel([</span><br><span class="line">    <span class="comment">// after decay, in parallel:</span></span><br><span class="line">    Animated.spring(position, &#123;</span><br><span class="line">      toValue: &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="comment">// return to start</span></span><br><span class="line">    &#125;),</span><br><span class="line">    Animated.timing(twirl, &#123;</span><br><span class="line">      <span class="comment">// and twirl</span></span><br><span class="line">      toValue: <span class="number">360</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">]).start(); <span class="comment">// start the sequence group</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，如果任何一个动画被停止或中断了，组内所有其它的动画也会被停止。Parallel 有一个stopTogether属性，如果设置为false，可以禁用自动停止。</p>
<p>在Animated文档的组合动画一节中列出了所有的组合方法。</p>
<h2 id="合成动画值">合成动画值</h2>
<p>你可以使用加减乘除以及取余等运算来把两个动画值合成为一个新的动画值：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#add">Animated.add()</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#subtract">Animated.subtract()</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#divide">Animated.divide()</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#modulo">Animated.modulo()</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#multiply">Animated.multiply()</a></p></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Animated.Value(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> b = Animated.divide(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">Animated.spring(a, &#123;</span><br><span class="line">  toValue: <span class="number">2</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h2 id="插值">插值</h2>
<p>所有动画值都可以执行插值（interpolation）操作。插值是指将一定范围的输入值映射到另一组不同的输出值，一般我们使用线性的映射，但是也可以使用 easing 函数。默认情况下，它会将曲线外推到给定范围之外，但您也可以让它限制为输出值. <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的将范围 0-1 转换为范围 0-100 的映射操作是：</span></span><br><span class="line">value.interpolate(&#123;</span><br><span class="line">  inputRange: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  outputRange: [<span class="number">0</span>, <span class="number">100</span>]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//通过使用 Animated.Value 的值从 0 变化到 1 来让 position 从 150px 变化到 0px，</span></span><br><span class="line"><span class="comment">//同时 opacity 从 0 变为 1。这一点可以通过将 style 从 example 修改为下面的样子来实现：</span></span><br><span class="line">style=&#123;&#123;</span><br><span class="line">  opacity: <span class="built_in">this</span>.state.fadeAnim, <span class="comment">// Binds directly</span></span><br><span class="line">  transform: [&#123;</span><br><span class="line">    translateY: <span class="built_in">this</span>.state.fadeAnim.interpolate(</span><br><span class="line">       inputRange: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       outputRange: [<span class="number">150</span>, <span class="number">0</span>]  <span class="comment">// 0 : 150, 0.5 : 75, 1 : 0</span></span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="comment">//多个区间的映射</span></span><br><span class="line">value.interpolate(&#123;</span><br><span class="line">  inputRange: [<span class="number">-300</span>, <span class="number">-100</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">101</span>],</span><br><span class="line">  outputRange: [<span class="number">300</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//支持到字符串的映射，从而可以实现颜色以及带有单位的值的动画变换。</span></span><br><span class="line">value.interpolate(&#123;</span><br><span class="line">  inputRange: [<span class="number">0</span>, <span class="number">360</span>],</span><br><span class="line">  outputRange: [<span class="string">&#x27;0deg&#x27;</span>, <span class="string">&#x27;360deg&#x27;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> ## 追踪动态值 动画中所设的值还可以通过跟踪别的值得到。你只要把 toValue 设置成另一个动态值而不是一个普通数字就行了。比如我们可以用弹跳动画来实现聊天头像的闪动，又比如通过timing设置duration:0来实现快速的跟随。他们还可以使用插值来进行组合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Animated.spring(follower, &#123; <span class="attr">toValue</span>: leader &#125;).start();</span><br><span class="line">Animated.timing(opacity, &#123;</span><br><span class="line">  toValue: pan.x.interpolate(&#123;</span><br><span class="line">    inputRange: [<span class="number">0</span>, <span class="number">300</span>],</span><br><span class="line">    outputRange: [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>变量 leader 和 follower 通过 Animated.ValueXY() 来定义。这是一个方便的处理 2D 交互的办法，譬如旋转或拖拽。它是一个简单的包含了两个Animated.Value实例的包装，然后提供了一系列辅助函数，使得ValueXY在许多时候可以替代Value来使用。比如在上面的代码片段中，leader和follower可以同时为valueXY类型，这样 x 和 y 的值都会被跟踪.</p>
<h2 id="跟踪手势"><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animations#%E8%B7%9F%E8%B8%AA%E6%89%8B%E5%8A%BF">跟踪手势</a></h2>
<p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/animated#event">Animated.event</a>是 Animated 中与输入有关的部分，允许手势或其它事件直接绑定到动态值上。它通过一个结构化的映射语法来完成，使得复杂事件对象中的值可以被正确的解开。第一层是一个数组，允许同时映射多个值，然后数组的每一个元素是一个嵌套的对象。在下面的例子里，你可以发现scrollX被映射到了event.nativeEvent.contentOffset.x(event通常是回调函数的第一个参数)，并且pan.x和pan.y分别映射到gestureState.dx和gestureState.dy（gestureState是传递给PanResponder回调函数的第二个参数）。</p>
<p>例如，在使用水平的滚动手势时，可以像下面这样将 event.nativeEvent.contentOffset.x 映射到 scrollX (一个 Animated.Value)。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onScroll=&#123;Animated.event(</span><br><span class="line">  <span class="comment">// scrollX = e.nativeEvent.contentOffset.x</span></span><br><span class="line">  [&#123; <span class="attr">nativeEvent</span>: &#123;</span><br><span class="line">       contentOffset: &#123;</span><br><span class="line">         x: scrollX</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;]</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="手势响应系统">手势响应系统</h2>
<p>复杂的手势响应 https://www.react-native.cn/docs/gesture-responder-system</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/%E6%89%8B%E5%8A%BF%E4%BA%A4%E4%BA%92/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="problems">problems</h1>
<h2 id="官方配置链接">官方配置链接</h2>
<p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/environment-setup">官网RN环境配置</a></p>
<h2 id="jdk版本不兼容问题">JDK版本不兼容问题</h2>
<h3 id="报错信息">报错信息：</h3>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/70632741/android-studio-error-unsupported-class-file-major-version-61">Android Studio Error &quot;Unsupported class file major version 62&quot;</a></p>
<h3 id="原因">原因：</h3>
<p>jdk版本过高，编译的类文件不匹配，&quot;version 62&quot;是指 jdk 18。</p>
<h3 id="解决方法">解决方法：</h3>
<ul>
<li><p>使用低版本的jdk，Android 工具链仅支持为 Java 11 编译的类（如果项目配置正确）。</p></li>
<li><p>如果遇到官网下载慢的问题，可以使用镜像网站下载。</p></li>
</ul>
<h3 id="相关链接">相关链接：</h3>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/70632741/android-studio-error-unsupported-class-file-major-version-61">stack_overflow：jdk问题</a></p>
<h2 id="vscode调试时的问题">VSCode调试时的问题</h2>
<h3 id="报错信息-1">报错信息：</h3>
<p>执行命令 _modules.bin-native.cmd run-android --no-packager 时出错 (error code 101)</p>
<h3 id="原因-1">原因：</h3>
<p>vs code启动模拟器的报错</p>
<h3 id="解决办法">解决办法：</h3>
<ol type="1">
<li><p>首先在终端通过 adb devices 检查模拟器或者真机是否正常链接。</p></li>
<li><p>然后重新刷新React Native工具包（在编译器底部栏）或者重启vscode。</p></li>
<li><p>最好先在命令行中通过cyarn android # 或者 yarn react-native run-android，启动工程后再尝试用VScode调试。</p></li>
<li><p>检查Metro服务（类似于webpack）是否正常启动，如果没有可以通过 yarn start 命令单独启动。</p></li>
</ol>
<h2 id="初始化构建ts模板react-native项目问题">初始化构建TS模板React Native项目问题</h2>
<h3 id="报错信息-2">报错信息：</h3>
<p>error An unexpected error occurred: &quot;http://r.npm.sankuai.com/react-native-template-react-native-template-typescript: Not found&quot;.</p>
<h3 id="原因-2">原因：</h3>
<p>react-native-cli是旧版本</p>
<h3 id="解决方法-1">解决方法：</h3>
<h4 id="方法1">方法1:</h4>
<p>删除旧的 react-native-cli:<code>npm uninstall -g react-native-cli</code></p>
<p>从“react-native-community”安装新的: <code>npm i -g @react-native-community/cli</code></p>
<p>之后，使用以下命令初始化项目: <code>npx react-native init MyApp --template react-native-template-typescript</code></p>
<h4 id="方法2方法1成功解决方法2并未尝试">方法2：（方法1成功解决，方法2并未尝试）</h4>
<p>运行以下命令开始升级到最新版本的过程: <code>npx react-native upgrade</code></p>
<p>你可以通过传递一个参数来指定一个 React Native 版本，例如升级到0.61.0-rc.0运行: <code>npx react-native upgrade 0.61.0-rc.0</code></p>
<p>相关链接： <strong>https://stackoverflow.com/questions/58078702/error-an-unexpected-error-occurred-https-registry-yarnpkg-com-react-native-t</strong></p>
<p>https://www.react-native.cn/docs/upgrading</p>
<h2 id="andorid-app-安装缺少密钥库问题">Andorid App 安装缺少密钥库问题</h2>
<h3 id="报错信息-3">报错信息</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Task :app:validateSigningDebug FAILED </span><br><span class="line">Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0.</span><br><span class="line">Use &#39;--warning-mode all&#39; to show the individual deprecation warnings</span><br><span class="line">See https:&#x2F;&#x2F;docs.gradle.org&#x2F;6.2&#x2F;userguide&#x2F;command_line_interface.html#sec:command_line_warnings</span><br><span class="line">94 actionable tasks: 94 executed</span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line"></span><br><span class="line">Execution failed for task &#39;:app:validateSigningDebug&#39;.</span><br><span class="line"></span><br><span class="line">&gt; Keystore file &#39;&#x2F;Users&#x2F;meibiao&#x2F;RN-ShoppingMall-master&#x2F;android&#x2F;app&#x2F;debug.keystore&#39; not found for signing config &#39;debug&#39;.</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line"></span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at https:&#x2F;&#x2F;help.gradle.org</span><br><span class="line"></span><br><span class="line">BUILD FAILED in 3m 24s</span><br></pre></td></tr></table></figure>
<h3 id="原因-3">原因</h3>
<p>问题是构建正在寻找调试密钥库并且找不到它，在android/app 文件夹下缺少密钥调试库。 应该是app构建apk时的需要的密钥库缺失。</p>
<h3 id="解决方案">解决方案</h3>
<h4 id="第一种">第一种：</h4>
<p>cd android/app 后运行命令 keytool -genkey -v -keystore debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000</p>
<p>（我使用的，已解决）</p>
<h4 id="第二种">第二种：</h4>
<p>只需从官方模板下载<strong>https://raw.githubusercontent.com/facebook/react-native/master/template/android/app/debug.keystore</strong></p>
<p>复制debug.keystore到您的android/app/.</p>
<h2 id="rn-fetch网络请求失败问题">RN fetch()网络请求失败问题</h2>
<h3 id="错误信息">错误信息</h3>
<p>RN开发中，我在本机上部署了node服务器端，客户端使用fetch()时返回错误&quot;network request failed&quot;。部署在android模拟器，URL为&quot;http://localhost:3000&quot;。</p>
<h3 id="原因-4">原因</h3>
<p>URL中的localhost的解析有问题。</p>
<blockquote>
<p>ps： 这里属于是自己脑子有点问题，琢磨了两天，也测试后端接受请求是否有问题，写demo测试能够请求到服务器，忘记了项目在模拟器上，&quot;localhost&quot; 解析会有问题。</p>
</blockquote>
<p>在查找解决方案的时候发现iOS上这样的情况也有，但问题可能是iOS不允许http请求，具体的解决方法可以参考<strong>https://stackoverflow.com/questions/38418998/react-native-fetch-network-request-failed</strong></p>
<h3 id="解决方法-2">解决方法</h3>
<p>终端 ifconfig 查询自己的服务器ip 将localhost更换为ip。</p>
<h2 id="react-nagivation-版本问题">React-Nagivation 版本问题</h2>
<h3 id="错误信息-1">错误信息</h3>
<p>App加载白屏。 调试器报以下错误 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Info] 07-08 14:40:23.511 29454 29510 E ReactNativeJS: Invariant Violation: Module AppRegistry is not a registered callable module (calling runApplication). A frequent cause of the error is that the application entry file path is incorrect.</span><br><span class="line"></span><br><span class="line">07-08 14:40:23.511 29454 29510 E ReactNativeJS: This can also happen when the JS bundle is corrupt or there is an early initialization error when loading React Native.</span><br></pre></td></tr></table></figure></p>
<h3 id="原因-5">原因</h3>
<p>导航器的版本用了4.x.x，引起了一些错误。</p>
<h3 id="解决办法-1">解决办法</h3>
<p>安装导航器（这是我们使用3.x版本） yarn add react-navigation@3.12.0</p>
<blockquote>
<p>ps: 没安装handler会报500</p>
</blockquote>
<p>安装navigation-handler yarn add react-native-gesture-handler react-native-reanimated</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/RN_problems/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="flexbox-布局">FlexBox 布局</h1>
<h2 id="简介">简介</h2>
<p>我们在 React Native 中使用 flexbox 规则来指定某个组件的子元素的布局。Flexbox 可以在不同屏幕尺寸上提供一致的布局结构。</p>
<p>一般来说，使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>
<h2 id="相关链接">相关链接</h2>
<p><a target="_blank" rel="noopener" href="https://www.react-native.cn/docs/layout-props#">全部的属性链接</a>。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/688b9108a922">比较全面的总结</a>。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3699a6e34e50">关于position</a>。</p>
<p><a target="_blank" rel="noopener" href="https://lefex.gitee.io/books/css-book/flexbox.html#flex-container-%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7">即使展示的总结</a></p>
<h2 id="容器">容器</h2>
<p>容器的margin（到外容器的距离）和padding（到内容器的距离） <img src="/images/React_native/flexbox-1.png" /> <img src="/images/React_native/flexbox-2.png" /></p>
<h2 id="react-native-与-css-的对比">React Native 与 CSS 的对比</h2>
<p>React Native 中的 Flexbox 的工作原理和 web 上的 CSS 基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值为column（而不是row），alignContent默认值为 flex-start（而不是 stretch）, flexShrink 默认值为0 （而不是1）, 而flex只能指定一个数字值。</p>
<h2 id="常用属性">常用属性</h2>
<h3 id="flex">Flex</h3>
<p>Flex 属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex 属性值被分割成多个部分属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex 属性值按比例被分割成多个部分。</p>
<p>在设置了flex: 1的容器 view 中，有红色，黄色和绿色三个子 view。红色 view 设置了flex: 1，黄色 view 设置了flex: 2，绿色 view 设置了flex: 3。<strong>1+2+3 = 6</strong>，这意味着红色 view 占据整个区域的1/6，黄色 view 占据整个区域的2/6，绿色 view 占据整个区域的3/6。 <img src="/images/React_native/flexbox-3.png" /></p>
<h3 id="flex-direction">Flex Direction</h3>
<p>在组件的style中指定flexDirection可以决定布局的<strong>主轴</strong>。决定子元素是应该沿着<strong>水平轴(row)</strong>方向排列，还是沿着<strong>竖直轴(column)</strong>方向排列.默认值是<strong>竖直轴(column)</strong>方向。</p>
<ul>
<li><p><strong>ROW（默认）</strong> 从左到右对齐孩子。如果启用了换行，则下一行将从容器左侧的第一项下方开始。</p></li>
<li><p><strong>COLUMN</strong> 从上到下对齐子项。如果启用了换行，则下一行将从容器顶部的左侧第一项开始。</p></li>
<li><p><strong>ROW REVERSE</strong> 将孩子从右到左对齐。如果启用了换行，则下一行将从容器右侧的第一项下方开始。</p></li>
<li><p><strong>COLUMN REVERSE</strong> 将子项从下到上对齐。如果启用了换行，则下一行将从容器底部的左侧第一项开始。</p></li>
</ul>
<h3 id="layout-direction">Layout Direction</h3>
<p>布局方向指定层次结构中的子项和文本的布局方向。 布局方向也会影响边缘开始和结束所指的内容。 默认情况下，React Native 使用 LTR 布局方向进行布局。 在这种模式下，start 指的是左，end 指的是右。</p>
<ul>
<li><p><strong>LTR（默认值）</strong> 文本和子项从左到右排列。 应用于元素开头的边距和填充应用于左侧。</p></li>
<li><p><strong>RTL</strong> 文本和子元素从右到左排列。 应用于元素开头的边距和填充应用于右侧。</p></li>
</ul>
<h3 id="justify-content">Justify Content</h3>
<p>在组件的 style 中指定justifyContent可以决定其子元素沿着<strong>主轴</strong>的<strong>排列方式</strong>。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？可用的选项有：</p>
<ul>
<li><p><strong>flex-start(默认值)</strong> 将容器的子项与容器主轴的起点对齐。</p></li>
<li><p><strong>flex-end</strong> 将容器的子元素与容器主轴的末端对齐。</p></li>
<li><p><strong>center</strong> 在容器主轴的中心对齐容器的子项。</p></li>
<li><p><strong>space-between</strong> 在容器的主轴上均匀地隔开子级，在子级之间分配剩余空间。</p></li>
<li><p><strong>space-around</strong> 在容器的主轴上均匀地隔开子项，将剩余的空间分布在子项周围。 与 space-between 相比，使用 space-around 将导致空间被分配到第一个孩子的开头和最后一个孩子的结尾。</p></li>
<li><p><strong>space-evenly</strong> 在对齐容器内沿主轴均匀分布子项。 每对相邻项之间的间距，主开始边和第一项，主结束边和最后一项，都完全相同。</p></li>
</ul>
<h3 id="align-items">Align Items</h3>
<p>在组件的 style 中指定alignItems可以决定其子元素沿着<strong>次轴</strong>（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的<strong>排列方式</strong>。决定子元素是应该靠近次轴的起始端还是末尾段分布亦或应该均匀分布。可用的选项有:</p>
<ul>
<li><p><strong>strength（默认值）</strong> 拉伸容器的子项以匹配容器横轴的高度。</p></li>
<li><p><strong>flex-start</strong> 将容器的子项与容器的交叉轴的起点对齐。</p></li>
<li><p><strong>flex-end</strong> 将容器的子项与容器的横轴末端对齐。</p></li>
<li><p><strong>center</strong> 在容器横轴的中心对齐容器的子项。</p></li>
<li><p><strong>baseline</strong> 沿公共基线对齐容器的子项。 可以将单个孩子设置为其父母的参考基线。</p></li>
<li><p>注意：要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。以下面的代码为例：只有将子元素样式中的width: 50去掉之后，alignItems: 'stretch'才能生效。</p></li>
</ul>
<h3 id="align-self">Align Self</h3>
<p>alignSelf 具有与 alignItems 相同的选项和效果，但您可以将此属性应用于单个子项以更改其在其父项中的对齐方式，而不是影响容器中的子项。 alignSelf 使用时覆盖父级alignItems 设置的任何选项。</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/FlexBox%E5%B8%83%E5%B1%80/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="react-基础知识">React 基础知识</h1>
<h2 id="总览">总览</h2>
<p><img src="/images/react/React基础框架.png" /></p>
<h2 id="react的元素渲染">React的元素渲染</h2>
<h3 id="元素">元素</h3>
<p>元素是构成 React 应用的最小单位，它用于描述屏幕上输出的内容。 <code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code> 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。</p>
<h3 id="渲染">渲染</h3>
<p>在此 div 中的所有内容都将由 React DOM 来管理，所以我们将其称为 &quot;根&quot; DOM 节点。</p>
<p>我们用 React 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React 的话，你可能会需要在不同的部分单独定义 React 根节点。</p>
<p>要将React元素渲染到根DOM节点中，我们通过把它们都传递给 <code>ReactDOM.render()</code> 的方法来将其渲染到页面上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>; </span><br><span class="line">ReactDOM.render( element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) );</span><br></pre></td></tr></table></figure>
<h2 id="组件开发">组件开发</h2>
<ul>
<li>class组件</li>
<li>函数组件</li>
</ul>
<h3 id="函数组件">函数组件</h3>
<p>我们封装一个输出 &quot;Hello World！&quot; 的组件，组件名为 HelloMessage： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> /&gt;</span></span>;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure> <code>const element = &lt;HelloMessage /&gt;</code>为用户自定义的组件。</p>
<p><em>注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。</em></p>
<p>如果我们需要向组件传递参数，可以使用 props,实例如下: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">props</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;props.name&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&quot;Runoob&quot;</span>/&gt;</span></span>; </span><br><span class="line">ReactDOM.render( </span><br><span class="line">  element, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure> 复合组件实例 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Name</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站名称：&#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Url</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站地址：&#123;props.url&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Nickname</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站小名：&#123;props.nickname&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Name name=<span class="string">&quot;菜鸟教程&quot;</span> /&gt;</span><br><span class="line">        &lt;Url url=<span class="string">&quot;http://www.runoob.com&quot;</span> /&gt;</span><br><span class="line">        &lt;Nickname nickname=<span class="string">&quot;Runoob&quot;</span> /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">     &lt;App /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="类组件">类组件</h3>
<p>除了函数组件外我们还可以创建一个 React.Component 的 ES6 类，该类封装了要展示的元素，需要注意的是在 render() 方法中，需要使用 <strong>this.props</strong> 替换 <strong>props</strong>。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;现在是 &#123;<span class="built_in">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="jsx语法">JSX语法</h2>
<p>React 使用 JSX 来替代常规的 JavaScript。(<strong>常用箭头函数</strong>)</p>
<p>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。</p>
<p>我们不需要一定使用 JSX，但它有以下优点：</p>
<ul>
<li><p>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</p></li>
<li><p>它是类型安全的，在编译过程中就能发现错误。</p></li>
<li><p>使用 JSX 编写模板更加简单快速。</p></li>
</ul>
<p>代码示例： <code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></p>
<h2 id="react-state状态">React State(状态)</h2>
<p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p>
<p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。</p>
<p>以下实例创建一个名称扩展为 React.Component 的 ES6 类，在 render() 方法中使用 this.state 来修改当前的时间。</p>
<p>添加一个类构造函数来初始化状态 this.state，类组件应始终使用 props 调用基础构造函数。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;现在是 &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="react-props">React Props</h2>
<p>state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。</p>
<h3 id="默认props">默认props</h3>
<p>可以通过组建类的 defalutProps属性设置默认值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;<span class="built_in">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">HelloMessage.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span>/&gt;</span></span>;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="生命周期">生命周期</h2>
<p><img src="/images/react/React生命周期图解.png" /> 组件的生命周期可分成三个状态：</p>
<ul>
<li><p><strong>Mounting(挂载)</strong>：已插入真实 DOM</p></li>
<li><p><strong>Updating(更新)</strong>：正在被重新渲染</p></li>
<li><p><strong>Unmounting(卸载)</strong>：已移出真实 DOM</p></li>
</ul>
<h3 id="生命周期方法">生命周期方法</h3>
<p>在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。</p>
<p>每当 Clock 组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为<strong>挂载</strong>。</p>
<p>同样，每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为<strong>卸载</strong>。</p>
<p><strong>componentDidMount()</strong> 与 <strong>componentWillUnmount()</strong> 方法被称作生命周期钩子。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">      () =&gt; <span class="built_in">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;现在是 &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="挂载">挂载</h3>
<p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p>
<ul>
<li><p><strong>constructor()]</strong>: 在 React 组件挂载之前，会调用它的构造函数。</p></li>
<li><p><strong>getDerivedStateFromProps()</strong>: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</p></li>
<li><p><strong>render()</strong>: render() 方法是 class 组件中唯一必须实现的方法。</p></li>
<li><p><strong>componentDidMount()</strong>: 在组件挂载后（插入 DOM 树中）立即调用。</p></li>
</ul>
<h3 id="更新">更新</h3>
<p>每当组件的 state 或 props 发生变化时，组件就会更新。</p>
<p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li><p><strong>getDerivedStateFromProps()</strong>: 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p></li>
<li><p><strong>shouldComponentUpdate()</strong>:当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。</p></li>
<li><p><strong>render()</strong>: render() 方法是 class 组件中唯一必须实现的方法。</p></li>
<li><p><strong>getSnapshotBeforeUpdate()</strong>: 在最近一次渲染输出（提交到 DOM 节点）之前调用。</p></li>
<li><p><strong>componentDidUpdate()</strong>: 在更新后会被立即调用。</p></li>
</ul>
<h3 id="卸载">卸载</h3>
<p>当组件从 DOM 中移除时会调用如下方法：</p>
<ul>
<li><strong>componentWillUnmount()</strong>: 在组件卸载及销毁之前直接调用。</li>
</ul>
<p>render() 方法是 class 组件中唯一必须实现的方法，其他方法可以根据自己的需要来实现。这些方法的详细说明，可以参考<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#reference">官方文档</a>。</p>
<p>一个组件加载的过程： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Component WILL MOUNT!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;Component DID MOUNT!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//------------------------------------------------ 挂载后</span></span><br><span class="line">  componentWillReceiveProps(newProps) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Component WILL RECEIVE PROPS!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(newProps, newState) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Component WILL UPDATE!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Component DID UPDATE!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;Component WILL UNMOUNT!&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据自顶向下流动">数据自顶向下流动</h3>
<p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。</p>
<p>这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。</p>
<p>这通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。</p>
<p>如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。</p>
<p>为了表明所有组件都是真正隔离的，我们可以创建一个 App 组件，它渲染三个Clock： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>现在是 &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">      () =&gt; <span class="built_in">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">   render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;FormattedDate date=&#123;<span class="built_in">this</span>.state.date&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="react组件api">React组件API</h2>
<ul>
<li><strong>setState(设置状态)</strong>: <code>setState(object nextState[, function callback])</code>
<ul>
<li><p><strong>nextState</strong>，将要设置的新状态，该状态会和当前的<strong>state</strong>合并</p></li>
<li><p><strong>callback</strong>，可选参数，回调函数。该函数会在<strong>setState</strong>设置成功，且组件重新渲染后调用。</p></li>
</ul>
<ol type="1">
<li>不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。</li>
<li>setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。</li>
<li>setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。</li>
</ol></li>
<li><strong>replaceState(替换状态)</strong>: <code>replaceState(object nextState[, function callback])</code>
<ul>
<li><p><strong>nextState</strong>，将要设置的新状态，该状态会替换当前的<strong>state</strong>。</p></li>
<li><p><strong>callback</strong>，可选参数，回调函数。该函数会在<strong>replaceState</strong>设置成功，且组件重新渲染后调用。</p></li>
</ul>
<p><strong>replaceState()</strong>方法与<strong>setState()</strong>类似，但是方法只会保留<strong>nextState</strong>中状态，原<strong>state</strong>不在<strong>nextState</strong>中的状态都会被删除。</p></li>
<li><strong>setProps(设置属性)</strong>: <code>setProps(object nextProps[, function callback])</code>
<ul>
<li><p>设置组件属性，并重新渲染组件。</p></li>
<li><p><strong>props</strong>相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知<strong>React.render()</strong>组件需要重新渲染，可以使用<strong>setProps()</strong>。</p></li>
<li>更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。</li>
</ul></li>
<li><strong>replaceProps(替换属性)</strong>: <code>replaceProps(object nextProps[, function callback])</code>
<ul>
<li><p><strong>nextProps</strong>，将要设置的新属性，该属性会替换当前的<strong>props</strong>。</p></li>
<li><p><strong>callback</strong>，可选参数，回调函数。该函数会在<strong>replaceProps</strong>设置成功，且组件重新渲染后调用。 <strong>replaceProps()</strong>方法与<strong>setProps</strong>类似，但它会删除原有<strong>props</strong>。</p></li>
</ul></li>
<li><strong>forceUpdate(强制更新)</strong>: <code>forceUpdate([function callback])</code>
<ul>
<li><strong>callback</strong>，可选参数，回调函数。该函数会在组件<strong>render()</strong>方法调用后调用。</li>
</ul>
<ol type="1">
<li><p>forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。</p></li>
<li><p>forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()</p></li>
<li><p>一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。</p></li>
</ol></li>
<li><strong>findDOMNode(获取DOM节点)</strong>: <code>DOMElement findDOMNode()</code>
<ul>
<li>返回值：<strong>true</strong>或<strong>false</strong>，表示组件是否已挂载到DOM中</li>
</ul>
<ol type="1">
<li><p>isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。</p></li>
<li><p>isMounted 的方法在 ES6 中已经废除。主要的原因是它经过实际使用与测试可能不足以检测组件是否挂载，尤其是对于有一些异步的程序情况，以及逻辑上造成混乱。现在用以下方法代替：<strong>componentDidMount() { this.mounted = true; } componentWillUnmount() { this.mounted = false; }</strong></p></li>
</ol></li>
</ul>
<h2 id="setstate须知">SetState()须知:</h2>
<ol type="1">
<li><strong>不要直接更新状态</strong></li>
</ol>
<p>例如，此代码不会重新渲染组件：</p>
<p><code>// Wrong this.state.comment = 'Hello';</code></p>
<p>应当使用 setState():</p>
<p><code>// Correct this.setState(&#123;comment: 'Hello'&#125;);</code></p>
<p>构造函数是唯一能够初始化 this.state 的地方。</p>
<ol start="2" type="1">
<li><strong>状态更新可能是异步的</strong></li>
</ol>
<p>React 可以将多个 setState() 调用合并成一个调用来提高性能。</p>
<p>因为 this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。</p>
<p>例如，此代码可能无法更新计数器：</p>
<p><code>// Wrong this.setState(&#123; counter: this.state.counter + this.props.increment, &#125;);</code></p>
<p>要修复它，请使用第二种形式的 setState() 来接受一个函数而不是一个对象。 该函数将接收先前的状态作为第一个参数，将此次更新被应用时的props做为第二个参数：</p>
<p><code>// Correct this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment &#125;));</code></p>
<p>上方代码使用了箭头函数，但它也适用于常规函数：</p>
<p><code>// Correct this.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;; &#125;);</code></p>
<ol start="3" type="1">
<li><strong>状态更新合并</strong></li>
</ol>
<p>当你调用 setState() 时，React 将你提供的对象合并到当前状态。</p>
<p>例如，你的状态可能包含一些独立的变量：</p>
<p><code>constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125;</code></p>
<p>你可以调用 setState() 独立地更新它们：</p>
<p><code>componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125;</code></p>
<p>这里的合并是浅合并，也就是说 this.setState({comments}) 完整保留了 this.state.posts，但完全替换了 this.state.comments。</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="react-hooks">react Hooks</h1>
<h2 id="介绍">介绍</h2>
<p>Hooks 是让你从函数组件中“钩入”React 状态和生命周期特性的函数。Hooks 在类中不起作用——它们让你在没有类的情况下使用 React。</p>
<p><strong>理解</strong>：函数组件没有办法存储react的状态和状态转移的操作，于是加入了钩子（Hook）来提供React的状态和对React操作的接口。</p>
<h2 id="使用规则">使用规则</h2>
<p>Hooks 是 JavaScript 函数，但它们强加了两个额外的规则：</p>
<ul>
<li><p>只在顶层调用 Hooks 。不要在循环、条件或嵌套函数中调用 Hook。</p></li>
<li><p>仅从 React 函数组件调用 Hooks 。不要从常规 JavaScript 函数调用 Hooks。（还有一个有效的地方可以调用 Hooks——你自己的自定义 Hooks。我们稍后会了解它们。）</p></li>
<li><p>可以建立自定义的Hook，但是记住用use开头，否则检查规则会不通过。</p></li>
<li><p>详细规则：<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-rules.html">Hooks 规则</a></p></li>
</ul>
<h2 id="basic-hooks">Basic Hooks</h2>
<ul>
<li><p><strong>useState</strong>: <code>const [state,setState] = useState(initialState);</code></p>
<ul>
<li><p>返回一个有状态的值，以及一个更新它的函数。</p></li>
<li><p>在初始渲染期间，返回的状态 ( state) 与作为第一个参数 ( initialState) 传递的值相同。</p></li>
<li><p>该setState函数用于更新状态。它接受一个新的状态值并将组件的重新渲染排入队列。</p></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">          Count: &#123;count&#125;</span><br><span class="line">          &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(initialCount)&#125;&gt;</span><br><span class="line">              Reset</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>)&#125;&gt;</span><br><span class="line">              -</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">              +</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>useEffect</strong>: <code>useEffect(didUpdate);</code>
<ul>
<li><p>接受包含命令式的、可能有效的代码的函数。</p></li>
<li><p>函数组件的主体（称为 React 的渲染阶段）中不允许突变、订阅、计时器、日志记录和其他副作用。 这样做会导致 UI 中出现令人困惑的错误和不一致。</p></li>
<li><p>传递给 useEffect 的函数将在渲染提交到屏幕后运行。</p></li>
<li><p>默认情况下，效果会在每次完成渲染后运行，但您可以选择仅在某些值发生更改时触发它们。渲染前触发使用useLayoutEffect。</p></li>
<li><p>传递给的函数useEffect可以返回一个清理函数，在组件从DOM中卸载时调用。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回清理函数</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Clean up the subscription</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//条件触发，第二个参数改变时会触发</span></span><br><span class="line">useEffect(</span><br><span class="line">() =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">[props.source],</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p><strong>useContext</strong>: <code>const value = useContext(MyContext);</code></p>
<ul>
<li><p>接受一个上下文对象（从 React.createContext 返回的值）并返回该上下文的当前上下文值。 当前上下文值由树中调用组件上方最近的 &lt;MyContext.Provider&gt; 的 value prop 确定。</p></li>
<li><p>当组件上方最近的 &lt;MyContext.Provider&gt; 更新时，此 Hook 将触发重新渲染，并将最新的上下文值传递给该 MyContext 提供程序。 即使祖先使用 React.memo 或 shouldComponentUpdate，仍然会使用 useContext 从组件本身开始重新渲染。</p></li>
<li><p>参数 MyContext必须是上下文对象本身：</p>
<ul>
<li><p><strong>正确的</strong>： useContext(MyContext)</p></li>
<li><p><strong>不正确</strong>： useContext(MyContext.Consumer)</p></li>
<li><p><strong>不正确</strong>： useContext(MyContext.Provider) <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">    light: &#123;</span><br><span class="line">        foreground: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">        background: <span class="string">&quot;#eeeeee&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    dark: &#123;</span><br><span class="line">        foreground: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">        background: <span class="string">&quot;#222222&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">        &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;ThemedButton /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button style=&#123;&#123; <span class="attr">background</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;&gt;</span><br><span class="line">        I am styled by theme context!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="additional-hooks">Additional Hooks</h2>
<ul>
<li><strong>useReducer</strong>: <code>const [state, dispatch] = useReducer(reducer, initialArg, init);</code>
<ul>
<li><p>useState的替代方法，接受一个（state，action）=&gt; newState 类型的reducer，并返回与调度方法配对的当前状态。</p></li>
<li><p>当具有涉及多个子值的复杂状态逻辑或下一个状态取决于前一个状态时，useReducer比useState更优秀。useReducer还可以优化触发深度更新的组件的性能，因为可以传递dispatch而不是回调。</p></li>
<li>设定指定状态：
<ul>
<li><p>最简单的方法是将初始状态作为第二个参数传递。</p></li>
<li><p>也可以迟钝地创建初始状态：传递一个init函数作为第三个参数。初始状态将设置为init(initialArg)。</p></li>
</ul></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定初始状态</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延迟设定状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span>, <span class="attr">payload</span>: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>useCallback</strong>: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回一个记忆化的回调。</p></li>
<li><p>传递一个内联回调和一组依赖项。useCallback将返回回调的记忆版本，仅当依赖项之一发生更改时才会更改。这在将回调传递给依赖引用相等以防止不必要的渲染的优化子组件时（例如shouldComponentUpdate）很有用。</p></li>
<li><p><strong>useCallback(fn, deps)相当于useMemo(() =&gt; fn, deps)</strong>。</p></li>
</ul></li>
<li><strong>useMemo</strong>: <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code>
<ul>
<li><p>返回一个记忆值。</p></li>
<li><p>传递一个“create”函数和一个依赖数组。useMemo仅当依赖项之一发生更改时才会重新计算记忆值。这种优化有助于避免在每次渲染时进行昂贵的计算。<strong>请记住，传递给的函数useMemo在渲染期间运行。不要在那里做任何你在渲染时通常不会做的事情。例如，副作用属于useEffect，而不是useMemo。</strong></p></li>
<li><p>如果没有提供数组，则每次渲染都会计算一个新值。您可以依赖useMemo作为性能优化，而不是作为语义保证。将来，React 可能会选择“忘记”一些先前记忆的值并在下一次渲染时重新计算它们，例如为屏幕外组件释放内存。编写你的代码，让它在没有的情况下仍然可以工作useMemo——然后添加它以优化性能。</p></li>
</ul></li>
<li><strong>useRef</strong>: <code>const refContainer = useRef(initialValue);</code>
<ul>
<li><p>useRef返回一个可变 ref 对象，其.current属性初始化为传递的参数 ( initialValue)。返回的对象将在组件的整个生命周期内持续存在。</p></li>
<li><p>有些情况下，我们需要保证函数组件每次 render 之后，某些变量不会被重复申明，比如说 Dom 节点，定时器的 id 等等。</p></li>
<li><p>在类组件中，我们完全可以通过给类添加一个自定义属性来保留，比如说 this.xxx， 但是函数组件没有 this，我们就需要使用 useRef 来实现。</p></li>
</ul>
<p>与useState的对比：</p>
<ul>
<li><p>useState的值更新触发重新渲染，useRef的值更新不触发渲染。</p></li>
<li><p>useState的是异步更新react的，useRef是同步更新的。</p></li>
</ul></li>
<li><strong>useImpeativeHandle</strong>: <code>useImperativeHandle(ref, createHandle, [deps])</code>
<ul>
<li><p>子组件利用useImperativeHandle可以呈现方法或者属性给让父组件调用，可以控制显示的视野有多少。</p></li>
<li><p>ref:需要被赋值的ref对象。</p></li>
<li><p>createHandle: createHandle函数的返回值作为ref.current的值。</p></li>
<li><p>[deps]: 依赖数组，依赖发生变化会重新执行createHandle函数。</p></li>
<li><p>建议useImperativeHandle和forwardRef同时使用，减少暴露给父组件的属性，避免使用<strong>ref</strong>这样的命令式代码。</p></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;  useRef,forwardRef,MutableRefObject,useImperativeHandle,Ref&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//只暴露value、getType、focus给父级</span></span><br><span class="line"><span class="keyword">const</span> InputEl = forwardRef((props: &#123;&#125;, <span class="attr">ref</span>: Ref&lt;any&gt;): JSX.Element=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl: MutableRefObject&lt;any&gt; = useRef();</span><br><span class="line">​</span><br><span class="line">    useImperativeHandle(ref, <span class="function">()=&gt;</span>(&#123;<span class="comment">//第一个参数：暴露哪个ref；第二个参数：暴露什么</span></span><br><span class="line">        value: (inputEl.current <span class="keyword">as</span> HTMLInputElement).value,</span><br><span class="line">        getType: <span class="function">() =&gt;</span> (inputEl.current <span class="keyword">as</span> HTMLInputElement).type,</span><br><span class="line">        focus: <span class="function">() =&gt;</span> (inputEl.current <span class="keyword">as</span> HTMLInputElement).focus()</span><br><span class="line">    &#125;));</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;input ref=&#123;inputEl&#125; type=<span class="string">&quot;text&quot;</span> &#123;...props&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//暴露整个input节点给父级</span></span><br><span class="line"><span class="keyword">const</span> InputEl = forwardRef((props: &#123;&#125;, <span class="attr">ref</span>: Ref&lt;any&gt;): JSX.Element=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;input ref=&#123;ref&#125; type=<span class="string">&quot;text&quot;</span> &#123;...props&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line"><span class="comment">//父级</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl: MutableRefObject&lt;any&gt; = useRef(<span class="literal">null</span>);</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onButtonClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;子组件input的对象:&#x27;</span>, inputEl.current);</span><br><span class="line">        inputEl.current.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;InputEl ref=&#123;inputEl&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>useLayoutEffect</strong>:</p>
<ul>
<li><p>模板与 useEffect 相同，但它在所有 DOM 突变后同步触发。 使用它从 DOM 中读取布局并同步重新渲染。 在 useLayoutEffect 中安排的更新将在浏览器有机会绘制之前同步刷新。</p></li>
<li><p>尽可能首选标准 useEffect 以避免阻塞视觉更新。</p></li>
</ul></li>
<li><p><strong>useDebugValue</strong>: <code>useDebugValue(value)</code></p>
<p>useDebugValue可用于在 React DevTools 中显示自定义钩子的标签。</p>
<p>例如，考虑在“构建您自己的 Hooks”中描述的 useFriendStatus 自定义 Hook。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">// Show a label in DevTools next to this Hook</span></span><br><span class="line">  <span class="comment">// e.g. &quot;FriendStatus: Online&quot;</span></span><br><span class="line">  useDebugValue(isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>);</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>useTransition</strong>: <code>const [isPending, startTransition] = useTransition();</code></p>
<p>返回转换的挂起状态的有状态值，以及启动它的函数。</p>
<ul>
<li><p>startTransition 将提供的回调中的更新标记为转换。</p></li>
<li>isPending 指示转换何时处于活动状态。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isPending, startTransition] = useTransition();</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    startTransition(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isPending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;&#123;count&#125;&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>useId</strong>: <code>const id = useId();</code></p>
<ul>
<li><p>useId是一个钩子，用于生成在服务器和客户端之间稳定的唯一 ID，同时避免水合不匹配。</p></li>
<li><p>useId不适用于在列表中生成<strong>键</strong>。密钥应该从您的数据中生成。</p></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个ID，将id直接传递给需要它的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Checkbox</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = useId();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;label htmlFor=&#123;id&#125;&gt;Do you like React?&lt;/label&gt;</span><br><span class="line">      &lt;input id=&#123;id&#125; type=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;react&quot;</span>/&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多个ID，对于同一组件中的多个 ID，请使用相同的 附加后缀id：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameFields</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = useId();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;label htmlFor=&#123;id + <span class="string">&#x27;-firstName&#x27;</span>&#125;&gt;First Name&lt;/label&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input id=&#123;id + <span class="string">&#x27;-firstName&#x27;</span>&#125; type=<span class="string">&quot;text&quot;</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;label htmlFor=&#123;id + <span class="string">&#x27;-lastName&#x27;</span>&#125;&gt;Last Name&lt;/label&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input id=&#123;id + <span class="string">&#x27;-lastName&#x27;</span>&#125; type=<span class="string">&quot;text&quot;</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="library-hooks为库作者提供的">Library Hooks(为库作者提供的)</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">名称</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">useSyncExternalStore</td>
<td style="text-align: center;">https://reactjs.org/docs/hooks-reference.html#library-hooks</td>
</tr>
<tr class="even">
<td style="text-align: center;">useInsertionEffect</td>
<td style="text-align: center;">https://reactjs.org/docs/hooks-reference.html#useinsertioneffect</td>
</tr>
</tbody>
</table></li>
</ul>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/Hooks/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
                
                    <article class="kratos-hentry kratos-entry-border-new clearfix">
                        <div class="kratos-status">
                            
                                <i class="fa fa-refresh"></i>
                            
                            <div class="kratos-status-inner">
                                <div class="kratos-status-content">
                                    
                                        <h1 id="npm-下载react项目时发生的错误">npm 下载react项目时发生的错误</h1>
<h2 id="问题名">问题名</h2>
<p><strong>eresolve unable to resolve dependency tree react</strong> ## 原因 npm install 因版本问题导致的报错， 依赖项中存在无法解决的冲突，npm@7 现在尝试安装它们，而npm@6没有 <img src="/images/react/pro1-1.png" /> ## <a target="_blank" rel="noopener" href="https://www.codegrepper.com/code-examples/javascript/npm+err+eresolve+unable+to+resolve+dependency+tree+react">解决方案</a>： 使用了 npm config set legacy-peer-deps true 命令解决了问题 <img src="/images/react/pro1-2.png" /> <strong><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/349716">原理</a></strong>：npm 从版本v7开始，install就默认以 peerDependencies的方式去下载了。命令用于绕过peerDependency里依赖的自动安装，它告诉npm忽略项目中引入的各个依赖模块之间依赖相同但版本不同的问题，以npm v3-v6的方式去继续执行安装操作</p>

                                    
                                </div>
                            </div>
                        </div>
                        
                            <footer class="kratos-post-meta-new">
                                <span class="pull-left">
                                    <a><i class="fa fa-calendar"></i></a><a>2022-09-02</a>
                                    <a><i class="fa fa-tags"></i></a>
                                    
                                </span>
                                <span class="pull-right">
                                    <a class="read-more" href="/SmartBoyMB.github.io/2022/09/02/npm%E4%B8%8B%E8%BD%BDreact%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%8F%91%E7%94%9F%E7%9A%84%E9%94%99%E8%AF%AF/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                                </span>
                            </footer>
                        
                    </article>
                
            
            
            
                <div class='text-center pagination'>
                <span class="page-number current">1</span><a class="page-number" href="/SmartBoyMB.github.io/page/2/">2</a><a class="page-number" href="/SmartBoyMB.github.io/page/3/">3</a><a class="extend next" rel="next" href="/SmartBoyMB.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
                </div>
            
        </section>

        </div>
                
            <section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
                
                    <aside id="krw-about" class="widget widget-kratos-about clearfix">
    
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="https://s.gravatar.com/avatar/8bdf15a341bdc59bbbe2cdb1eb781eb4?s=80" />
        </div>
    </div>
    <div class="textwidget">
        
            <p class="text-center">沅湘是清水</p>
        
    </div>
</aside>
                
                    <!-- Moved to about.ejs -->
                
                    
  <aside id="krw-categories" class="widget widget-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/SmartBoyMB.github.io/categories/%E5%AD%A6%E4%B9%A0/">学习</a><span class="category-list-count">10</span></li></ul>
  </aside>


                
                    
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/SmartBoyMB.github.io/tags/LaTeX/" style="font-size: 0.6em;">LaTeX</a> <a href="/SmartBoyMB.github.io/tags/blog/" style="font-size: 0.67em;">blog</a> <a href="/SmartBoyMB.github.io/tags/folder/" style="font-size: 0.6em;">folder</a> <a href="/SmartBoyMB.github.io/tags/hexo/" style="font-size: 0.67em;">hexo</a> <a href="/SmartBoyMB.github.io/tags/mathjax/" style="font-size: 0.6em;">mathjax</a> <a href="/SmartBoyMB.github.io/tags/python/" style="font-size: 0.6em;">python</a> <a href="/SmartBoyMB.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.6em;">机器学习</a> <a href="/SmartBoyMB.github.io/tags/%E6%A6%82%E5%BF%B5/" style="font-size: 0.73em;">概念</a> <a href="/SmartBoyMB.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 0.8em;">知识图谱</a> <a href="/SmartBoyMB.github.io/tags/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/" style="font-size: 0.6em;">论文学习</a>
      </div>
  </aside>

                
                    
  <aside id="krw-posts" class="widget widget-kratos-poststab">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            <a class="list-group-item" href="/SmartBoyMB.github.io/2021/05/10/MachineLearning/"><i class="fa  fa-book"></i> MachineLearning</a>
            
          
        
          
          
            <a class="list-group-item" href="/SmartBoyMB.github.io/2020/11/21/pythonLearning/"><i class="fa  fa-book"></i> pythonLearning</a>
            
          
        
          
          
            <a class="list-group-item" href="/SmartBoyMB.github.io/2020/11/06/longtailrelation/"><i class="fa  fa-book"></i> long tail Relation</a>
            
          
        
          
          
            <a class="list-group-item" href="/SmartBoyMB.github.io/2020/11/04/xiaoyangbenzhishitupu/"><i class="fa  fa-book"></i> 少样本知识图谱推理</a>
            
          
        
          
          
            <a class="list-group-item" href="/SmartBoyMB.github.io/2020/11/04/howtosetmathjax/"><i class="fa  fa-book"></i> hexo 主题使用mathjax插件渲染LaTeX数学公式的问题</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

                
            </section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer">
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/SmartBoyMB.github.io/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/CandyUnion"><i class="fa fa-telegram"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://twitter.com/Candiinya"><i class="fa fa-twitter"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://github.com/SmartBoyMB"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 Mei Biao 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Made with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by <a href="https://candinya.com" target="_blank" rel="nofollow">Candinya</a>.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>

<script async src="/js/candy.min.js"></script>


    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>


    </body>
</html>